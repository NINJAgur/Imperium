"""
Module Imperium.py
====================================================================================

This module contains the main application, it's configuration + sub classes
"""

__version__ = '1.0'
__author__ = 'Edan Gurin'

'''
KIVY 1.11.0 IMPORTED PACKAGES
'''

from kivy.config import Config

Config.set('graphics', 'resizable', True)
Config.set('input', 'mouse', 'mouse, multitouch_on_demand')

from kivy.animation import Animation
from kivy.properties import BooleanProperty, ObjectProperty
from kivy.uix.screenmanager import ScreenManager
from kivy.uix.widget import Widget
from kivy.uix.slider import Slider
from kivy.uix.popup import Popup

'===================================================================================='
'''
Python 3.7.4 IMPORTED PACKAGES
'''
from functools import partial
import random, copy, math, itertools
from math import degrees, atan2

'===================================================================================='
'''
Project imports from Imperium/src
'''
from src.A_star import astar
from src.Info_Button import *
from src.Empire import Empire
from src.Support_func import *
from src.Next_Turn_Button import *
from src.Screens import *

Window.fullscreen = True  # fullscreen setting

'===================================================================================='
'''
PROJECT IMPERIUM
================
'''


class Imperium_Game(ScreenManager):
    """
    Screen manager. This is the main class that will control your
    class: Screen stack and memory.
    Class Method :
        Add a new or existing screen to the ScreenManager and switch to it.
        The previous screen will be "switched away".
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        """
        Function Method : 
            initialize self and class param
            ===============================
        """
        """
        Screens children of Screen Manager :
        1. Main Menu Screen
        2. Empire Selection Screen
        3. Game Screen
        # Tutorial and it's screens 
            4. Tutorial Screen
            5. Movement_Screen 
            6. Diplomacy Screen 
            7. Resources Screen
            8. Victory Screen
        """
        self.menu_screen = MainMenu(name='Menu')
        self.selection_screen = Selection(name='Selection screen')
        self.game_screen = MainGame(name='Imperium')
        self.Tutorial_screen = Tutorial(name='Tutorial')
        self.rome_screen = Movement_Screen(name='Movement Screen')
        self.carthage_screen = Diplomacy_Screen(name='Diplomacy Screen')
        self.egypt_screen = Resources_Screen(name='Resources Screen')
        self.victory_screen = Victory_Screen(name='Victory screen')

        self.add_widget(self.menu_screen)
        self.add_widget(self.selection_screen)
        self.add_widget(self.game_screen)
        self.add_widget(self.Tutorial_screen)
        self.add_widget(self.rome_screen)
        self.add_widget(self.carthage_screen)
        self.add_widget(self.egypt_screen)
        self.add_widget(self.victory_screen)


'------------------------------------------------------------------------------------'


class Decisions_Btn(Button):
    """
     Class Method :
        create buttons for diplomacy and empire communication
    """

    def __init__(self, pos, type, empire, main_widget, **kwargs):
        super(Decisions_Btn, self).__init__(**kwargs)
        """
        Function Method : 
        initialize self and class param
        ===============================
            :param pos: pos received from parent
            :param type: button type in according to it's role in diplomacy / game messages
            :param empire: empire that the decision button will affect
            :param main_widget: parent of the class
        """
        self.empire = empire  # in documetation above
        self.pos = pos  # self pos
        self.border = (0, 0, 0, 0)  # border set to prevent incorrect rescalling
        self.type = type  # in documetation above
        self.text = type.capitalize()  # text on the button (if there is)
        self.font_size = GetSystemMetrics(0) / 85  # font size to scale with system resolution size
        self.parent_widget = main_widget  # in documetation above
        self.layout = Widget()  # in the diplomacy tab this is the widget containting diplomacy buttons for empire 1
        self.layout2 = Widget()  # in the diplomacy tab this is the widget containting diplomacy buttons for empire 2
        self.cities = GridLayout(cols=1,
                                 size_hint_y=None)  # in the unit recruitment tab this is the widget containting city locations buttons
        self.cities.bind(minimum_height=self.cities.setter('height'))  # setting infinite minimum height
        self.scrlv_cities = ScrollView(size_hint=(0.2, 0.3), pos=(self.parent_widget.width / 6,
                                                                  self.parent_widget.height / 3))  # Scrollview object containing self.cities (scrollable sub- screen)
        self.parent_widget.add_widget(self.layout)  # adding to parent (Main Game screen)
        self.parent_widget.add_widget(self.layout2)  # adding to parent (Main Game screen)

    def on_press(self):
        """
            Function Method :
            initialized on Decisions_Btn press event
            ========================================
        """
        self.opacity = 0.5
        # empire proposal
        proposal = ""
        # score block - relations score that is required for both empires to have to get to an agreement
        score_block = 0
        if self.type.find("non aggression") != -1:
            proposal = "non aggression"
            score_block = 40
        elif self.type.find("trade agreement") != -1:
            proposal = "trade agreement"
            score_block = 10
        elif self.type.find("military access") != -1:
            proposal = "military access"
            score_block = 70
        elif self.type.find("peace") != -1:
            proposal = "peace"
        elif self.type.find("war") != -1:
            proposal = "War"
        elif self.type.find("relations") != -1:
            proposal = "relations"

        # case empire agress to proposal
        if self.type.find("Agree") != -1:
            sound = SoundLoader.load('assets/audio/agreement_signed.mp3')
            sound.play()
            if self.empire == self.parent_widget.e1:
                self.parent_widget.empire.dip1[proposal] = True
                self.empire.dip1[proposal] = True
            else:
                self.parent_widget.empire.dip2[proposal] = True
                self.empire.dip1[proposal] = True

            if proposal == 'peace':
                sound = SoundLoader.load('assets/audio/peace.mp3')
                sound.play()
                self.parent_widget.UPDATESPopup("Peace signed with " + str(self.empire.name))
                unit_counter = 0
                self.empire.dip1["war"] = False
                self.parent_widget.empire.dip1["war"] = False
                for unit in self.parent_widget.empire.units:
                    if self.empire.tile_arr[unit.loc[0]][unit.loc[1]] == 'O':
                        self.parent_widget.remove_widget(unit)
                        unit_counter += 1

                for city in self.parent_widget.empire.cities:
                    if unit_counter > 0:
                        self.parent_widget.b.add_Unit(self.parent_widget.empire, city)
                        unit_counter -= 1

                if unit_counter > 0:
                    self.parent_widget.empire.treasury += unit_counter * 1000
                    self.parent_widget.empire.manpower += unit_counter * 1000

        # case user cancel diplomatic action or empire disagrees
        elif self.type.find("Disagree") != -1 or self.type.find("Cancel") != -1:
            play_sound(self)
            if self.empire == self.parent_widget.e1:
                self.parent_widget.empire.dip1[proposal] = False
            else:
                self.parent_widget.empire.dip2[proposal] = False
        # diplomacy actions management for both rival empires
        else:
            play_sound(self)
            if proposal == 'relations':
                self.parent_widget.player_diplomacy_Popup(self.empire, proposal, None)

            elif proposal == 'War' and self.parent_widget.empire.state == 'Peace':
                self.empire.state = 'War'
                self.parent_widget.empire.state = 'War'
                self.empire.dip1["peace"] = False
                self.empire.dip1["war"] = True
                self.empire.dip1["relations"] = -100
                if self.empire == self.parent_widget.e1:
                    self.parent_widget.empire.dip1["peace"] = False
                    self.parent_widget.empire.dip1["war"] = True
                    self.parent_widget.empire.dip1["relations"] = -100
                else:
                    self.parent_widget.empire.dip2["peace"] = False
                    self.parent_widget.empire.dip2["war"] = True
                    self.parent_widget.empire.dip2["relations"] = -100

                self.parent_widget.player_diplomacy_Popup(self.empire, proposal, None)

            elif proposal == 'Peace' and self.parent_widget.empire.state == 'War':
                if self.parent_widget.supremacy(self.empire, self.parent_widget.empire):
                    self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "disagrees")

                elif self.parent_widget.supremacy(self.empire, self.parent.empire):
                    self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "agrees")
                    self.empire.state = 'Peace'
                    self.parent_widget.empire.state = 'Peace'
                    self.empire.dip1["peace"] = True
                    self.empire.dip1["war"] = False
                    self.empire.update_diplomacy(self.parent_widget.empire, self.empire.rival_empires[1])
                    self.parent_widget.empire.update_diplomacy(self.parent_widget.e1, self.parent_widget.e2)
                    if self.empire == self.e1:
                        self.parent_widget.empire.dip1["peace"] = True
                        self.parent_widget.empire.dip1["war"] = False
                    else:
                        self.parent_widget.empire.dip2["peace"] = True
                        self.parent_widget.empire.dip2["war"] = False

            elif proposal != 'Peace' and proposal != 'War':
                if self.parent_widget.e1 == self.empire:
                    if self.parent_widget.empire.dip1[proposal] is not True and self.parent_widget.empire.dip1[
                        "relations"] >= score_block:
                        self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "agrees ")
                        self.parent_widget.empire.dip1[proposal] = True
                        self.empire.dip1[proposal] = True
                    elif self.parent_widget.empire.dip1[proposal] is True and self.parent_widget.empire.dip1[
                        "relations"] >= score_block:
                        self.parent_widget.UPDATESPopup("Agreement already signed!")
                    else:
                        self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "disagrees ")
                elif self.parent_widget.e2 == self.empire:
                    if self.parent_widget.empire.dip2[proposal] is not True and self.parent_widget.empire.dip2[
                        "relations"] >= score_block:
                        self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "agrees ")
                        self.parent_widget.empire.dip2[proposal] = True
                        self.empire.dip1[proposal] = True
                    elif self.parent_widget.empire.dip2[proposal] is True and self.parent_widget.empire.dip2[
                        "relations"] >= score_block:
                        self.parent_widget.UPDATESPopup("Agreement already signed!")
                    else:
                        self.parent_widget.player_diplomacy_Popup(self.empire, proposal, "disagrees ")

    def on_release(self):
        """
            Function Method :
            initialized on Decisions_Btn press event
            ========================================
        """
        # reset opacity
        self.opacity = 1
        # check if button is recruitment for either of unit types
        if self.type == 'Recruit Soldier' or self.type == 'Recruit Worker' or self.type == 'Recruit Warship':
            # adding city deployment buttons for Scrollview if no children exist for layout (user request to open sub- screen)
            if self.cities.children == []:
                self.scrlv_cities.clear_widgets()
                for city in self.empire.cities:
                    # buttons bound to add_unit_to_city() - see further
                    self.cities.add_widget(
                        Button(size_hint_y=None, height=100, text="Add " + self.type[8:] + " to City in " + str(city),
                               font_size=26, background_normal=os.path.join(self.parent_widget.titles_source),
                               background_down=os.path.join(self.parent_widget.titles_source_d),
                               on_release=self.add_unit_to_city))

                self.scrlv_cities.add_widget(self.cities)
                self.parent_widget.add_widget(self.scrlv_cities)
            # else remove them (user cancels sub screen)
            else:
                self.parent_widget.remove_widget(self.scrlv_cities)
                self.cities.clear_widgets()

        elif self.type == 'Diplomacy':
            # sound on button release
            sound = SoundLoader.load('assets/audio/diplomacy_click.mp3')
            sound.play()
            # adding diplomacy buttons for Scrollview if no children exist for layout (user request to open sub- screen)
            if self.layout.children == []:
                if self.parent_widget.e1.state != 'Defeat':
                    self.layout.add_widget(
                        Image(source=self.parent_widget.e1.img, pos=(Window.width / 3 + 80, Window.height / 1.2)))
                    i = 0
                    for title in self.parent_widget.empire.dip1:
                        self.layout.add_widget(Decisions_Btn((Window.width / 3, Window.height / 1.4 - i * 75), title,
                                                             self.parent_widget.e1, self.parent, size=(250, 75),
                                                             background_normal=self.parent_widget.titles_source,
                                                             background_down=self.parent_widget.titles_source_d))
                        i += 1
                        if title != 'war' and title != 'peace' and title != 'relations':
                            self.layout.add_widget(
                                Decisions_Btn((Window.width / 3, Window.height / 1.4 - i * 75), 'Cancel ' + title,
                                              self.parent_widget.e1, self.parent, size=(250, 75),
                                              background_normal=self.parent_widget.titles_source,
                                              background_down=self.parent_widget.titles_source_d))
                            i += 1

                if self.parent_widget.e2.state != 'Defeat':
                    self.layout.add_widget(
                        Image(source=self.parent_widget.e2.img, pos=(Window.width / 2 + 80, Window.height / 1.2)))
                    i = 0
                    for title in self.parent_widget.empire.dip2:
                        self.layout2.add_widget(Decisions_Btn((Window.width / 2, Window.height / 1.4 - i * 75), title,
                                                              self.parent_widget.e2, self.parent, size=(250, 75),
                                                              background_normal=self.parent_widget.titles_source,
                                                              background_down=self.parent_widget.titles_source_d))
                        i += 1
                        if title != 'war' and title != 'peace' and title != 'relations':
                            self.layout2.add_widget(
                                Decisions_Btn((Window.width / 2, Window.height / 1.4 - i * 75), 'Cancel ' + title,
                                              self.parent_widget.e2, self.parent, size=(250, 75),
                                              background_normal=self.parent_widget.titles_source,
                                              background_down=self.parent_widget.titles_source_d))
                            i += 1
            # else remove them (user cancels sub screen)
            else:
                self.layout.clear_widgets()
                self.layout2.clear_widgets()

    def add_unit_to_city(self, event):
        # calling add_[unit name] functions on press event (button)
        if self.type == 'Recruit Soldier':
            loc = event.text[24:-1]
            loc = tuple(map(int, loc.split(', ')))
            sound = SoundLoader.load('assets/audio/add_unit.mp3')
            sound.play()
            self.parent.add_Unit(self.parent.empire, loc)
        elif self.type == 'Recruit Worker':
            loc = event.text[23:-1]
            loc = tuple(map(int, loc.split(', ')))
            sound = SoundLoader.load('assets/audio/add_unit.mp3')
            sound.play()
            self.parent.add_Worker(self.parent.empire, loc)
        elif self.type == 'Recruit Warship':
            loc = event.text[24:-1]
            loc = tuple(map(int, loc.split(', ')))
            sound = SoundLoader.load('assets/audio/add_unit.mp3')
            sound.play()
            self.parent.add_WarShip(self.parent.empire, loc)


'------------------------------------------------------------------------------------'


class Board(Widget):
    """
    Class Board : The Widget class is the base class required for creating Widgets.

    Global class parameters :
    -sel
       BooleanProperty()
       Property that represents only a boolean value (set by default to False)

    -selected
       ObjectProperty()
       Property that represents a Python object.

    -selected_hex
        ObjectProperty()
       Property that represents a Python object.
    """
    selected = ObjectProperty(None)
    selected_hex = ObjectProperty(None)
    sel = BooleanProperty(False)

    def __init__(self, player_empire, parent_widget, **kwargs):
        '''
        :param player_empire: name of player empire
        :param parent_widget: parent class of scrollview object that contains the board class - Main Game Screen
        '''
        super(Board, self).__init__(**kwargs)
        """
            Function Method : 
                initialize self and class param
                ===============================
        """
        self.size = (3200, 2500)  # default size
        self.size_hint = (None, None)  # size hint to accomdate possible infinite size for Scrollview object
        self.arr = []  # array containing all hex objects
        self.player_empire = player_empire  # String player empire name
        background = CoreImage(os.path.join('assets', 'images',
                                            'finalmap.png'))  # background Image for pixel reading method developed by me
        empires = CoreImage(os.path.join('assets', 'images',
                                         'empires.png'))  # empires    Image for pixel reading method developed by me
        self.Rome = Empire(8300, 5500, (22, 29), "Rome", parent_widget)  # Rome Empire Class
        self.Carthage = Empire(5300, 5500, (14, 22), "Carthage", parent_widget)  # Carthage Empire Class
        self.Egypt = Empire(7300, 5500, (4, 58), "Egypt", parent_widget)  # Egypt Empire Class
        """
        BOARD INITIALIZATION - READ PIXEL METHOD
        
        The initilization of the board is done with function called .read_pixel(). This function receives 2 (x, 
        y) coordinates and scans the pixel in this location on a CoreImage object (loaded with source image) and 
        returns the RGBA (RED, GREEN, BLUE, ALPHA) Colour values. In this looped run I'm creating a 48 x 70 board 
        using this method. There are 2 CoreImages - First one for terrain and the second for Empire owned hexes which is
        applied only for green (grasslands / forest), yellow (desert) and grey (city) 
        
        Since the Board is filled with Hexagons - odd and even numbers have to have different pos calculations. 
        Note : There are 2 hex objects created on the same tile : Hex_Tile and Empire_HexTile - to accommodate Unit 
       abilities (- see further) """
        for i in range(48):
            for j in range(70):
                loc = (i, j)
                image_read_x = j * dis_width + 10
                if j % 2 == 0:
                    pos = (j * 45, 26 + 50 / 2 + i * 50)
                    image_read_y = background.height - dis_height - i * dis_height
                else:
                    pos = (j * 45, 26 + i * 50)
                    image_read_y = background.height - dis_height / 2 - i * dis_height
                # grassland / forest tile
                if background.read_pixel(image_read_x, image_read_y) == green:
                    self.hex = HexTile(pos, loc, "Grasslands")
                    self.add_widget(self.hex)
                    if empires.read_pixel(image_read_x, image_read_y) == red:
                        self.hex = Empire_HexTile(pos, loc, "Roman")
                        self.add_widget(self.hex)
                        self.Rome.add_locations(j, i)
                        self.Rome.tiles += 1
                    elif empires.read_pixel(image_read_x, image_read_y) == purple:
                        self.hex = Empire_HexTile(pos, loc, "Carthaginian")
                        self.add_widget(self.hex)
                        self.Carthage.add_locations(j, i)
                        self.Carthage.tiles += 1
                    elif empires.read_pixel(image_read_x, image_read_y) == yellow2:
                        self.hex = Empire_HexTile(pos, loc, "Egyptian")
                        self.add_widget(self.hex)
                        self.Egypt.add_locations(j, i)
                        self.Egypt.tiles += 1
                    else:
                        self.hex = Empire_HexTile(pos, loc, "Grasslands")
                        self.add_widget(self.hex)
                # desert
                elif background.read_pixel(image_read_x, image_read_y) == yellow:
                    self.hex = HexTile(pos, loc, "Desert")
                    self.add_widget(self.hex)
                    if empires.read_pixel(image_read_x, image_read_y) == red:
                        self.hex = Empire_HexTile(pos, loc, "Roman")
                        self.add_widget(self.hex)
                        self.Rome.add_locations(j, i)
                        self.Rome.tiles += 1
                    elif empires.read_pixel(image_read_x, image_read_y) == purple:
                        self.hex = Empire_HexTile(pos, loc, "Carthaginian")
                        self.add_widget(self.hex)
                        self.Carthage.add_locations(j, i)
                        self.Carthage.tiles += 1
                    elif empires.read_pixel(image_read_x, image_read_y) == yellow2:
                        self.hex = Empire_HexTile(pos, loc, "Egyptian")
                        self.add_widget(self.hex)
                        self.Egypt.add_locations(j, i)
                        self.Egypt.tiles += 1
                    else:
                        self.hex = Empire_HexTile(pos, loc, "Desert")
                        self.add_widget(self.hex)
                # sea
                elif background.read_pixel(image_read_x, image_read_y) == blue:
                    self.hex = HexTile(pos, loc, "Sea")
                    self.add_widget(self.hex)
                # mountains
                elif background.read_pixel(image_read_x, image_read_y) == brown:
                    self.hex = HexTile(pos, loc, "Mountains")
                    self.add_widget(self.hex)
                # water passage / shallow water
                elif background.read_pixel(image_read_x, image_read_y) == water_pass:
                    self.hex = HexTile(pos, loc, "pass")
                    self.add_widget(self.hex)
                # cities
                else:
                    self.hex = HexTile(pos, loc, "City")
                    self.add_widget(self.hex)
                    if empires.read_pixel(image_read_x, image_read_y) == red:
                        self.hex = Empire_HexTile(pos, loc, "Roman")
                        self.add_widget(self.hex)
                        self.hex.source = os.path.join('assets', 'images', '35_rome_hex_city.png')
                        self.Rome.add_locations(j, i)
                        self.Rome.tiles += 1
                        self.Rome.cities.append((i, j))

                    elif empires.read_pixel(image_read_x, image_read_y) == purple:
                        self.hex = Empire_HexTile(pos, loc, "Carthaginian")
                        self.add_widget(self.hex)
                        self.hex.source = os.path.join('assets', 'images', '36_carthage_hex_city.png')
                        self.Carthage.add_locations(j, i)
                        self.Carthage.tiles += 1
                        self.Carthage.cities.append((i, j))

                    elif empires.read_pixel(image_read_x, image_read_y) == yellow2:
                        self.hex = Empire_HexTile(pos, loc, "Egyptian")
                        self.add_widget(self.hex)
                        self.hex.source = os.path.join('assets', 'images', '37_egypt_hex_city.png')
                        self.Egypt.add_locations(j, i)
                        self.Egypt.tiles += 1
                        self.Egypt.cities.append((i, j))

                    else:
                        self.hex = Empire_HexTile(pos, loc, "City")
                        self.add_widget(self.hex)

    def on_touch_down(self, touch):
        '''
        Function Method :
            Handles touch down event - The touch is in parent children.
        :param touch: Receive a touch down event.
        '''
        # running through board children
        self.touch = touch  # touch parameter (handled in Units.py)
        for child in self.children:
            # if touch object is unit and it's score < 3 (can move and do actions) and it is player empire unit
            if child.collide_point(*touch.pos) and (type(child) == Empire_Unit or type(child) == Empire_Worker or type(
                    child) == Empire_Warship) and child.score < 3 and child.name == self.player_empire:
                '''
                if touch received is left mouse click :
                    if unit isnt pressed anymore - remove allowed moves locations - white hexes where the unit can go.
                    also play unit's empire specific voice line
                '''
                if touch.button == 'left' and touch.is_double_tap == False and touch.is_triple_tap == False:
                    self.selected = child
                    self.sel = True
                    if child.state == 'normal':
                        if self.player_empire == 'Rome':
                            if type(child) == Empire_Unit:
                                voicelines = [os.path.join('assets', 'audio', 'rome_soldier_voiceline1.mp3'),
                                              os.path.join('assets', 'audio', 'rome_soldier_voiceline2.mp3'),
                                              os.path.join('assets', 'audio', 'rome_soldier_voiceline3.mp3'),
                                              os.path.join('assets', 'audio', 'rome_soldier_voiceline4.mp3')]
                            elif type(child) == Empire_Warship:
                                voicelines = [os.path.join('assets', 'audio', 'rome_fleet_voiceline1.mp3'),
                                              os.path.join('assets', 'audio', 'rome_fleet_voiceline2.mp3'),
                                              os.path.join('assets', 'audio', 'rome_fleet_voiceline3.mp3')]
                            else:
                                voicelines = [os.path.join('assets', 'audio', 'rome_worker_voiceline.mp3')]

                        elif self.player_empire == 'Carthage':
                            if type(child) == Empire_Unit:
                                voicelines = [os.path.join('assets', 'audio', 'carthage_soldier_voiceline1.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_soldier_voiceline2.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_soldier_voiceline3.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_soldier_voiceline4.mp3')]
                            elif type(child) == Empire_Warship:
                                voicelines = [os.path.join('assets', 'audio', 'carthage_fleet_voiceline1.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_fleet_voiceline2.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_fleet_voiceline3.mp3'),
                                              os.path.join('assets', 'audio', 'carthage_fleet_voiceline4.mp3')]
                            else:
                                voicelines = [os.path.join('assets', 'audio', 'worker_voiceline.mp3')]

                        else:
                            if type(child) == Empire_Unit:
                                voicelines = [os.path.join('assets', 'audio', 'egypt_soldier_voiceline1.mp3'),
                                              os.path.join('assets', 'audio', 'egypt_soldier_voiceline2.mp3'),
                                              os.path.join('assets', 'audio', 'egypt_soldier_voiceline3.mp3'),
                                              os.path.join('assets', 'audio', 'egypt_soldier_voiceline4.mp3')]
                            elif type(child) == Empire_Warship:
                                voicelines = ['egypt_fleet_voiceline1.mp3', 'egypt_fleet_voiceline2.mp3',
                                              'egypt_fleet_voiceline3.mp3', 'egypt_fleet_voiceline4.mp3']
                            else:
                                voicelines = [os.path.join('assets', 'audio', 'worker_voiceline.mp3')]

                        sound = SoundLoader.load(random.choice(voicelines))
                        sound.play()

                    for child in self.children:
                        if type(child) == Empire_Unit or type(child) == Empire_Worker or type(
                                child) == Empire_Warship:
                            child.remove_tiles()
                    # dispatch the touch as usual to children
                    # the coordinate in the touch is now in local space
                    return super(Board, self).on_touch_down(touch)
                '''
                Right and middle click options (for each unique sound plays):
                '''
                if touch.button == 'right' and type(child) == Empire_Unit and \
                        self.parent.parent.empire.tile_arr[child.loc[0]][child.loc[1]] != 'O':
                    '''
                    if touch received is right mouse click and touch object is a soldier and the territory he stands 
                    isn't already the empire's territory - capture territory 
                    '''
                    for hex in self.children:
                        if type(hex) == Empire_HexTile and hex.loc == child.loc:
                            if self.player_empire == 'Rome':
                                hex.type = "Roman"
                                if locations[child.loc[0]][child.loc[1]] == 'c':
                                    hex.source = os.path.join('assets', 'images', '35_rome_hex_city.png')
                                    self.parent.parent.empire.cities.append((child.loc[0], child.loc[1]))
                                else:
                                    hex.source = os.path.join('assets', 'images', '35_rome_hex.png')
                            elif self.player_empire == 'Carthage':
                                hex.type = "Carthaginian"
                                if locations[child.loc[0]][child.loc[1]] == 'c':
                                    hex.source = os.path.join('assets', 'images', '36_carthage_hex_city.png')
                                    self.parent.parent.empire.cities.append((child.loc[0], child.loc[1]))
                                else:
                                    hex.source = os.path.join('assets', 'images', '36_carthage_hex.png')
                            elif self.player_empire == 'Egypt':
                                hex.type = "Egyptian"
                                if locations[child.loc[0]][child.loc[1]] == 'c':
                                    hex.source = os.path.join('assets', 'images', '37_egypt_hex_city.png')
                                    self.parent.parent.empire.cities.append((child.loc[0], child.loc[1]))
                                else:
                                    hex.source = os.path.join('assets', 'images', '37_egypt_hex.png')

                            sound = SoundLoader.load('assets/audio/soldier_action.mp3')
                            sound.play()

                            self.parent.parent.empire.add_locations(hex.loc[1], hex.loc[0])
                            self.parent.parent.empire.tiles += 1
                            child.score += 1
                            self.parent.parent.score += 1

                            if self.parent.parent.empire.state == 'War':
                                if self.parent.parent.e1.state == 'War' and \
                                        self.parent.parent.e1.tile_arr[hex.loc[0]][hex.loc[1]] == 'O':
                                    self.parent.parent.e1.tile_arr[hex.loc[0]][hex.loc[1]] = 1
                                    self.parent.parent.e1.tiles -= 1
                                    if locations[child.loc[0]][child.loc[1]] == 'c':
                                        self.parent.parent.e1.cities.remove((child.loc[0], child.loc[1]))

                                    if child.loc == self.parent.parent.e1.capital:
                                        self.parent.parent.e1.capital_captured = True
                                elif self.parent.parent.e2.state == 'War' and \
                                        self.parent.parent.e2.tile_arr[hex.loc[0]][hex.loc[1]] == 'O':
                                    self.parent.parent.e2.tile_arr[hex.loc[0]][hex.loc[1]] = 1
                                    self.parent.parent.e2.tiles -= 1
                                    if locations[child.loc[0]][child.loc[1]] == 'c':
                                        self.parent.parent.e2.cities.remove((child.loc[0], child.loc[1]))
                                    if child.loc == self.parent.parent.e2.capital:
                                        self.parent.parent.e2.capital_captured = True
                            break

                    return super(Board, self).on_touch_up(touch)

                elif touch.button == 'right' and type(child) == Empire_Worker and \
                        self.parent.parent.empire.tile_arr[child.loc[0]][child.loc[1]] == 'O' and \
                        locations[child.loc[0]][child.loc[1]] != 'c':
                    '''
                    if touch received is right mouse click and touch object is a worker and tile is empire territory and isnt already a farm - build farm
                    '''
                    for hex in self.children:
                        if type(hex) == Empire_HexTile and hex.loc[0] == child.loc[0] and hex.loc[1] == \
                                child.loc[1] and hex.source != os.path.join('assets', 'images', 'grass_hex.png'):
                            child.score += 1
                            self.parent.parent.score += 1
                            hex.source = os.path.join('assets', 'images', 'grass_hex.png')
                            child.opacity = 0.5
                            child.opacity = 1
                            self.parent.parent.empire.farms += 1
                            self.parent.parent.empire.farm_locs[hex.loc[0]][hex.loc[1]] = 'O'
                            sound = SoundLoader.load('assets/audio/worker_action.mp3')
                            sound.play()
                            break
                    return super(Board, self).on_touch_up(touch)

                elif touch.button == 'right' and type(child) == Empire_Warship:
                    '''
                    if touch received is right mouse click and touch object is a warship and tile nearby shore 
                    that is empty from empires or units - deploy a soldier and a worker there 
                    '''
                    if child.loc[1] % 2 == 0:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                            tile = (child.loc[0] + new_position[0], child.loc[1] + new_position[1])
                            if (locations[tile[0]][tile[1]] == 'g' or locations[tile[0]][tile[1]] == 'd' or
                                    locations[tile[0]][tile[1]] == 'c'):
                                free = False
                                for hex in self.children:
                                    if type(hex) == Empire_HexTile and hex.loc == tile and hex.occupied == False:
                                        free = True

                                if free:
                                    if self.parent.parent.empire.state == 'Peace':
                                        if self.parent.parent.e1.tile_arr[tile[0]][tile[1]] != 'O' and \
                                                self.parent.parent.e2.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)

                                    elif self.parent.parent.empire.state == 'War':
                                        if self.parent.parent.e1.state == 'War' and \
                                                self.parent.parent.e2.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)
                                        elif self.parent.parent.e2.state == 'War' and \
                                                self.parent.parent.e1.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)
                    else:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                            tile = (child.loc[0] + new_position[0], child.loc[1] + new_position[1])
                            if (locations[tile[0]][tile[1]] == 'g' or locations[tile[0]][tile[1]] == 'd' or
                                    locations[tile[0]][tile[1]] == 'c'):
                                free = False
                                for hex in self.children:
                                    if type(hex) == Empire_HexTile and hex.loc == tile and hex.occupied == False:
                                        free = True

                                if free:
                                    if self.parent.parent.empire.state == 'Peace':
                                        if self.parent.parent.e1.tile_arr[tile[0]][tile[1]] != 'O' and \
                                                self.parent.parent.e2.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)

                                    elif self.parent.parent.empire.state == 'War':
                                        if self.parent.parent.e1.state == 'War' and \
                                                self.parent.parent.e2.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)
                                        elif self.parent.parent.e2.state == 'War' and \
                                                self.parent.parent.e1.tile_arr[tile[0]][tile[1]] != 'O':
                                            self.parent.parent.add_Unit(self.parent.parent.empire, tile)
                                            self.parent.parent.add_Worker(self.parent.parent.empire, tile)
                                            child.score += 1
                                            self.parent.parent.score += 1
                                            sound = SoundLoader.load('assets/audio/naval_invasion.mp3')
                                            sound.play()
                                            return super(Board, self).on_touch_up(touch)

                        return super(Board, self).on_touch_down(touch)

                elif touch.button == 'middle' and (type(child) == Empire_Unit or type(child) == Empire_Warship):
                    '''
                    if touch received is middle mouse click and touch object is a soldier or a warship and empire 
                    has at least 500 manpower - give the unit 500 manpower, else return a popup saying 'no manpower' 
                    '''
                    if self.parent.parent.empire.manpower >= 500:
                        child.power += 500
                        self.parent.parent.empire.manpower -= 500
                        self.parent.parent.update_labels(self.parent.parent.empire)
                        sound = SoundLoader.load('assets/audio/add_unit.mp3')
                        sound.play()
                        self.parent.parent.UPDATESPopup("Added 500 men to unit at " + str(child.loc))
                    else:
                        self.parent.parent.UPDATESPopup("NO MORE MEN!")
                    return super(Board, self).on_touch_down(touch)


            # elif touch object is a hex of some sort
            elif child.collide_point(*touch.pos) and (type(child) == Empire_HexTile or type(child) == HexTile):
                sound = SoundLoader.load('assets/audio/button_click.mp3')
                sound.play()
                '''
                if object is hex and :
                    right clicked on it - hex_info(hex) function will run
                    left clicked on it - opacity changes to 0.5 
                        if it is a white hex - return on_touch_up
                '''
                if touch.button == 'right':
                    self.hex_info(child)
                else:
                    child.opacity = 0.5
                    self.selected_hex = child
                    if self.selected_hex.type == 'white' and touch.button == 'left' and self.selected_hex.collide_point(
                            *touch.pos):
                        return super(Board, self).on_touch_up(touch)
                break

    def on_touch_up(self, touch):
        '''
        Function Method :
            Handles touch down event - The touch is in parent children.
            :param touch: Receive a touch up event.
        '''
        # restore selected hex opacity
        if self.selected_hex != None:
            self.selected_hex.opacity = 1
        # verifying that self.selected is a unit that belongs to player empire and has score lower than 3
        if type(self.selected) == Empire_Unit or type(self.selected) == Empire_Worker or type(
                self.selected) == Empire_Warship and self.selected.score < 3:
            # validates touch coordinates in valid() function, moves the unit and plays unit's empire specific sound
            if self.selected_hex != None and self.selected != None and self.selected.state == 'down' and self.valid(
                    touch) and self.selected_hex.type == 'white' and touch.button == 'left':
                if self.player_empire == 'Rome':
                    if type(self.selected) == Empire_Unit:
                        voicelines = [os.path.join('assets', 'audio', 'rome_soldier_move1.mp3'),
                                      os.path.join('assets', 'audio', 'rome_soldier_move2.mp3'),
                                      os.path.join('assets', 'audio', 'rome_soldier_move3.mp3'),
                                      os.path.join('assets', 'audio', 'rome_soldier_move4.mp3')]
                    elif type(self.selected) == Empire_Warship:
                        voicelines = [os.path.join('assets', 'audio', 'rome_fleet_move1.mp3'),
                                      os.path.join('assets', 'audio', 'rome_fleet_move2.mp3'),
                                      os.path.join('assets', 'audio', 'rome_fleet_move3.mp3')]
                    else:
                        voicelines = [os.path.join('assets', 'audio', 'worker_move.mp3')]

                elif self.player_empire == 'Carthage':
                    if type(self.selected) == Empire_Unit:
                        voicelines = [os.path.join('assets', 'audio', 'carthage_soldier_move1.mp3'),
                                      os.path.join('assets', 'audio', 'carthage_soldier_move2.mp3'),
                                      os.path.join('assets', 'audio', 'carthage_soldier_move3.mp3'),
                                      os.path.join('assets', 'audio', 'carthage_soldier_move4.mp3')]
                    elif type(self.selected) == Empire_Warship:
                        voicelines = [os.path.join('assets', 'audio', 'carthage_fleet_move1.mp3'),
                                      os.path.join('assets', 'audio', 'carthage_fleet_move2.mp3'),
                                      os.path.join('assets', 'audio', 'carthage_fleet_move3.mp3')]
                    else:
                        voicelines = [os.path.join('assets', 'audio', 'worker_move.mp3')]

                else:
                    if type(self.selected) == Empire_Unit:
                        voicelines = [os.path.join('assets', 'audio', 'egypt_soldier_move1.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_soldier_move2.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_soldier_move3.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_soldier_move4.mp3')]
                    elif type(self.selected) == Empire_Warship:
                        voicelines = [os.path.join('assets', 'audio', 'egypt_fleet_move1.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_fleet_move2.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_fleet_move3.mp3'),
                                      os.path.join('assets', 'audio', 'egypt_fleet_move4.mp3')]
                    else:
                        voicelines = ['worker_move.mp3']

                sound = SoundLoader.load(random.choice(voicelines))
                sound.play()
                x = int((touch.pos[0]) / 45)
                if x % 2 == 0:
                    y = int((touch.pos[1] - 20) / 50) - 1
                    pos = (7 + x * 45, (y + 1) * 50 + 8)
                else:
                    y = int((touch.pos[1] - 20) / 50)
                    pos = (7 + x * 45, y * 50 + 65 / 2)

                self.angle = degrees(atan2(touch.y - self.center_y, touch.x - self.center_x))
                Animation(x=pos[0], y=pos[1], duration=0.5, angle=self.angle).start(self)
                self.selected.pos = pos
                for hex in self.children:
                    if type(hex) == Empire_HexTile and hex.loc == self.selected.loc and hex.occupied == True:
                        hex.occupied = False
                    if type(hex) == Empire_HexTile and hex.loc[0] == y and hex.loc[1] == x:
                        hex.occupied = True

                self.selected.state = 'normal'
                self.selected.loc = (y, x)
                self.selected.score += 1
                self.parent.parent.score += 1

            if self.sel == True:
                self.sel = False

    def valid(self, touch):
        """
        Function Method :
            Validates touch coordinates and returns bool values accordingly
            also handles unit combat in case of war
        :param touch - touch event:
        """
        x = int((touch.pos[0]) / 45)
        if x % 2 == 0:
            y = int((touch.pos[1] - 20) / 50) - 1
        else:
            y = int((touch.pos[1] - 20) / 50)

        # check if it's not the same location as the one the unit is currently standing
        if self.selected.loc[1] == x and self.selected.loc[0] == y:
            return False

        enemy_empire = None
        # case empire is in a state of war
        if self.parent.parent.empire.state == 'War':
            if self.parent.parent.e1.state == 'War':
                enemy_empire = self.parent.parent.e1

            elif self.parent.parent.e2.state == 'War':
                enemy_empire = self.parent.parent.e2

            '''
            Combat against other units if unit type is Soldier or Warship
            '''
            if enemy_empire != None:
                for unit in enemy_empire.units:
                    if ((type(unit) == Empire_Unit and type(self.selected) == Empire_Unit) or (
                            type(unit) == Empire_Warship and type(self.selected) == Empire_Warship)) and unit.loc == (
                            y, x):
                        if unit.power < self.selected.power:
                            self.selected.power -= unit.power
                            self.remove_widget(unit)
                            if type(unit) == Empire_Unit:
                                enemy_empire.army -= 1
                            else:
                                enemy_empire.ships -= 1
                            enemy_empire.units.remove(unit)

                        elif unit.power >= self.selected.power:
                            self.selected.remove_tiles()
                            unit.power -= self.selected.power
                            self.remove_widget(self.selected)
                            if type(unit) == Empire_Unit:
                                self.parent.parent.empire.army -= 1
                            else:
                                self.parent.parent.empire.ships -= 1
                            self.parent.parent.score -= self.selected.score + 1
                            self.parent.parent.empire.units.remove(self.selected)
                            self.parent.parent.max_score = self.parent.parent.empire.army * 3 + self.parent.parent.empire.workers * 3 + self.parent.parent.empire.ships * 3
                            self.parent.parent.Lost_unit(self.selected.loc)
                        break

                    elif type(unit) == Empire_Worker and unit.loc == (y, x) and unit.name == enemy_empire.name:
                        self.remove_widget(unit)
                        enemy_empire.workers -= 1
                        enemy_empire.units.remove(unit)
                        break
        # check if location x, y is in range - prevents random jumps caused
        if (self.selected.loc[1] - x < 2 and self.selected.loc[1] - x > -2) and (
                self.selected.loc[0] - y < 2 and self.selected.loc[0] - y > -2):

            if self.selected.loc[0] < y and self.selected.loc[1] % 2 != 0 and self.selected.loc[1] - x != 0:
                return False
            elif self.selected.loc[0] > y and self.selected.loc[1] % 2 == 0 and self.selected.loc[1] - x != 0:
                return False
            else:
                return True
        else:
            return False


    def hex_info(self, hex):
        """
        Function Method :
            creates a Popup mini- window with a text with hex parameters - location and owner, and exit button
        :param hex:
        """
        layout = GridLayout(cols=1, padding=10)
        type = Label(text='Hex is ' + hex.type, font_size=24)
        layout.add_widget(type)
        pos = Label(text='Position ' + str(hex.loc[0]) + " , " + str(hex.loc[1]), font_size=24)
        layout.add_widget(pos)
        b = Button(text="RETURN")
        layout.add_widget(b)
        popup = Popup(title="Hex stats", content=layout, size_hint=(None, None), size=(400, 400), auto_dismiss=False)
        popup.open()
        b.bind(on_release=popup.dismiss)


'------------------------------------------------------------------------------------'

'''
Main Game Class
'''


class MainGame(Screen):
    """
     Class Method :
        The main screen where the player game happens and it's configurations.
        MainGame Screen is an element intended to be used with a :class:`ScreenManager`.

        Since this screen is a huge amount of code i will provide here it's structure :
        1. init
        2. main functions
        3. AI - minimax algorithm
        4. support functions
    """
    '''================================================__INIT__======================================================'''

    def __init__(self, **kwargs):
        super(MainGame, self).__init__(**kwargs)
        self.size = (GetSystemMetrics(0), GetSystemMetrics(1))  # system default screen size
        self.scrlv = ScrollView()  # scrollview object that will house the board class
        self.year = -250  # starter year
        self.prev_turn = 0  # previous turn
        self.turn = 0  # starter turn
        Window.bind(on_resize=self.on_window_resize)  # window bound to on_window_resize()

    # init of the classes game functions player + empire name string received from Selection screen class
    def initialize(self, play_empire):
        self.player_empire = play_empire
        # init user map
        self.init_map()
        # init game
        self.init_game()

    '''===========================================MAIN GAME FUNCTIONS================================================'''

    """MAP INIT"""

    def init_map(self):
        """USER MAP INIT IN BOARD OBJ"""
        self.b = Board(self.player_empire, self)
        """
        SETUP FOR BASED ON USER'S EMPIRE (with initiation of scrollview window)
        -----------------------------------------------------------------------
        """
        if self.player_empire == "Rome":
            self.scrlv = ScrollView(size=(GetSystemMetrics(0), GetSystemMetrics(1)), size_hint=(None, None),
                                    bar_color=(1.0, 1.0, 1.0, 0), scroll_x=0.4, scroll_y=0.35)
            self.banner = Image(source=os.path.join('assets', 'images', 'rome_banner.png'), allow_stretch=True,
                                keep_ratio=False, size_hint=(.1, .2), pos=(0, self.height * 0.8))
            self.titles_source = os.path.join('assets', 'images', '57_header.png')
            self.titles_source_d = os.path.join('assets', 'images', '57_header_d.png')
            self.empire = self.b.Rome
            self.empire.img = os.path.join('assets', 'images', 'rome_symbol.png')
            self.e1 = self.b.Carthage
            self.e1.img = os.path.join('assets', 'images', 'carthage_symbol.png')
            self.e2 = self.b.Egypt
            self.e2.img = os.path.join('assets', 'images', 'egypt_symbol.png')

        elif self.player_empire == "Carthage":
            self.scrlv = ScrollView(size=(GetSystemMetrics(0), GetSystemMetrics(1)), size_hint=(None, None),
                                    bar_color=(1.0, 1.0, 1.0, 0), scroll_x=0.2, scroll_y=0.2)
            self.banner = Image(source=os.path.join('assets', 'images', 'carthage_banner.png'), allow_stretch=True,
                                keep_ratio=False, size_hint=(.1, .2), pos=(0, self.height * 0.8))
            self.titles_source = os.path.join('assets', 'images', '58_header2.png')
            self.titles_source_d = os.path.join('assets', 'images', '58_header2_d.png')
            self.empire = self.b.Carthage
            self.empire.img = os.path.join('assets', 'images', 'carthage_symbol.png')
            self.e1 = self.b.Rome
            self.e1.img = os.path.join('assets', 'images', 'rome_symbol.png')
            self.e2 = self.b.Egypt
            self.e2.img = os.path.join('assets', 'images', 'egypt_symbol.png')

        elif self.player_empire == "Egypt":
            self.scrlv = ScrollView(size=(GetSystemMetrics(0), GetSystemMetrics(1)), size_hint=(None, None),
                                    bar_color=(1.0, 1.0, 1.0, 0), scroll_x=1, scroll_y=0)
            self.banner = Image(source=os.path.join('assets', 'images', 'egypt_banner.png'), allow_stretch=True,
                                keep_ratio=False, size_hint=(.1, .2), pos=(0, self.height * 0.8))
            self.titles_source = os.path.join('assets', 'images', '59_header3.png')
            self.titles_source_d = os.path.join('assets', 'images', '59_header3_d.png')
            self.empire = self.b.Egypt
            self.empire.img = os.path.join('assets', 'images', 'egypt_symbol.png')
            self.e1 = self.b.Rome
            self.e1.img = os.path.join('assets', 'images', 'rome_symbol.png')
            self.e2 = self.b.Carthage
            self.e2.img = os.path.join('assets', 'images', 'carthage_symbol.png')
        """scrlv adds board"""
        self.scrlv.add_widget(self.b)
        """sliders for easier map rotation"""
        s = Slider(min=0, max=1, value=0.5, orientation='vertical', step=0.01, size_hint=(None, None),
                   size=(50, self.scrlv.height / 3), pos=(0.9 * self.scrlv.width, self.scrlv.height / 3))
        s2 = Slider(min=0, max=1, value=0.5, orientation='horizontal', step=0.01, size_hint=(None, None),
                    size=(self.scrlv.width / 3, 50), pos=(self.scrlv.width / 3, self.scrlv.height / 40))
        self.scrlv.bind(scroll_y=partial(self.slider_change, s))
        self.scrlv.bind(scroll_x=partial(self.slider_change, s2))
        s.bind(value=partial(self.scroll_change, self.scrlv))
        s2.bind(value=partial(self.scroll_change2, self.scrlv))
        # frame
        frame = Image(source=os.path.join('assets', 'images', '27_frame.png'), allow_stretch=True, keep_ratio=False,
                      size_hint=(None, None), size=(self.width, self.height))
        self.add_widget(self.scrlv)

        """
        USER INTERFACE BUTTONS INIT :
        -----------------------------------------------------------------------
        """
        # soldier recruit button
        self.rec_sldr = Decisions_Btn((self.width / 35, self.height / 1.8), "Recruit Soldier", self.empire, self,
                                      size_hint=(0.1, 0.1), background_normal=self.titles_source,
                                      background_down=self.titles_source_d)
        # worker recruit button
        self.rec_wrkr = Decisions_Btn((self.width / 35, self.height / 2.2), "Recruit Worker", self.empire, self,
                                      size_hint=(0.1, 0.1), background_normal=self.titles_source,
                                      background_down=self.titles_source_d)
        # warship recruit button
        self.rec_ship = Decisions_Btn((self.width / 35, self.height / 2.9), "Recruit Warship", self.empire, self,
                                      size_hint=(0.1, 0.1), background_normal=self.titles_source,
                                      background_down=self.titles_source_d)
        # diplomacy button
        self.diplomacy_btn = Decisions_Btn((self.width / 35, self.height / 1.5), "Diplomacy", self.empire, self,
                                           size_hint=(0.1, 0.1), background_normal=self.titles_source,
                                           background_down=self.titles_source_d)
        # quit button
        quit = Button(size_hint=(0.1, 0.05), pos=(self.width * 0.88, self.height * 0.93),
                      background_normal=os.path.join('assets', 'images', '14_quit_u.png'),
                      background_down=os.path.join('assets', 'images', '13_quit_d.png'), on_press=play_sound,
                      on_release=self.exit)
        # info button for user game questions
        info = Info_Button(self, size_hint=(0.05, 0.05), pos=(self.width * 0.83, self.height * 0.93),
                           background_normal=self.titles_source, background_down=self.titles_source_d, text='INFO',
                           font_size=24)
        # year button (static, pressable but doesnt do anyting)
        self.year_button = Button(background_normal=self.titles_source, background_down=self.titles_source_d,
                                  text='Year : -250', font_size='30', size_hint=(0.15, 0.05),
                                  pos=(self.width * 0.65, self.height * 0.93))
        # next turn button
        self.next_year = NextYear_Btn()

        self.add_widget(frame)
        self.add_widget(self.year_button)
        self.add_widget(self.next_year)
        self.add_widget(s)
        self.add_widget(s2)
        self.add_widget(info)
        self.add_widget(self.banner)
        self.add_widget(quit)
        self.add_widget(self.rec_sldr)
        self.add_widget(self.rec_wrkr)
        self.add_widget(self.rec_ship)
        self.add_widget(self.diplomacy_btn)
        # text labels for resource update function
        self.textures = ["MANPOWER", "STABILITY", "TREASURY"]
        # resource labels grid horizontal layout
        self.labels = GridLayout(rows=1, pos=(self.width / 4, self.height - self.height / 8), size_hint=(0.5, 0.05),
                                 spacing=10)
        """BASE UNITS INITIATION"""
        self.empire.original_tiles = self.empire.tiles
        self.e1.original_tiles = self.e1.tiles
        self.e2.original_tiles = self.e2.tiles
        self.add_Unit(self.b.Rome, self.b.Rome.capital)
        self.add_Worker(self.b.Rome, self.b.Rome.capital)
        self.add_WarShip(self.b.Rome, self.b.Rome.capital)
        self.add_Unit(self.b.Carthage, self.b.Carthage.capital)
        self.add_Worker(self.b.Carthage, self.b.Carthage.capital)
        self.add_WarShip(self.b.Carthage, self.b.Carthage.capital)
        self.add_Unit(self.b.Egypt, self.b.Egypt.capital)
        self.add_Worker(self.b.Egypt, self.b.Egypt.capital)
        self.add_WarShip(self.b.Egypt, self.b.Egypt.capital)

    """GAME INIT"""

    def init_game(self):
        # song playlist init
        playlist = [os.path.join('assets', 'audio', 'sountrack1.mp3'),
                    os.path.join('assets', 'audio', 'sountrack2.mp3'),
                    os.path.join('assets', 'audio', 'sountrack3.mp3')]
        # play songs in for loop
        for song in playlist:
            sound = SoundLoader.load(song)
            sound.volume = 0.1
            sound.play()
        # RIVAL EMPIRES FOR DIPLOMACY FUNCTIONS
        self.empire.rival_empires = [self.e1, self.e2]
        self.e1.rival_empires = [self.empire, self.e2]
        self.e2.rival_empires = [self.empire, self.e1]
        self.empire.update_diplomacy(self.e1, self.e2)
        self.e1.update_diplomacy(self.empire, self.e2)
        self.e2.update_diplomacy(self.empire, self.e1)
        # UPDATE USER EMPIRE BEFORE FIRST TURN (just in case)
        self.empire.update_stability()
        self.update_labels(self.empire)
        self.player_play()

    """PLAYER TURN"""

    def player_play(self):
        # check if player empire has been defeated
        self.check_defeat(self.empire)
        if self.empire.state != 'Defeat':
            # CHECK WIN
            self.checkWin()
            # CALCULATE MAX SCORE
            self.max_score = self.empire.army * 3 + self.empire.workers * 3 + self.empire.ships * 3
            # RESET OVERALL SCORE
            self.score = 0
            # RESET CHILD SCORES
            # RESET CHILD SCORES
            if self.turn != self.prev_turn:
                for unit in self.empire.units:
                    unit.score = 0
                self.prev_turn = self.turn
        else:
            # continue AI only game
            self.update_year()
            return self.empire1_play()

    """ENEMY EMPIRE 1 TURN"""

    def empire1_play(self):
        # check if AI empire 1 has been defeated
        self.check_defeat(self.e1)
        if self.e1.state != 'Defeat':
            # check for victory
            self.checkWin()
            # update empire's resources
            self.e1.update_treasury()
            self.e1.update_manpower()
            self.e1.update_stability()
            # reset unit scores for player empire and empire 2 for clean minimax run
            for unit in self.empire.units:
                unit.score = 0
            for unit in self.e2.units:
                unit.score = 0
            """INIT OF THE CLONE EMPIRES FOR MINIMAX RUN"""
            prop1 = self.copy_empire(self.e1)
            prop2 = self.copy_empire(self.empire)
            prop3 = self.copy_empire(self.e2)
            """CLONE BOARD AND UNIT LOCATIONS BOARD INIT"""
            if self.e1.name == 'Rome' and self.empire.name == 'Carthage':
                board = buildMap(prop1, prop2, prop3)
                unit_loc = units_Map(prop1, prop2, prop3)

            elif self.e1.name == 'Carthage' and self.empire.name == 'Rome':
                board = buildMap(prop2, prop1, prop3)
                unit_loc = units_Map(prop2, prop1, prop3)
            else:
                board = buildMap(prop1, prop3, prop2)
                unit_loc = units_Map(prop1, prop3, prop2)

            self.minimaxed = prop1  # MINIMAXED EMPIRE - SELF
            '''THE MINIMAX RUN- the decision is received from it'''
            empire_decision = self.minimax(board, locations, unit_loc, prop1, prop2, prop3, 3, prop1, MIN, MAX, None)
            """CLONE BOARD AND UNIT LOCATIONS BOARD INIT - for graphical implementation"""
            if self.e1.name == 'Rome' and self.empire.name == 'Carthage':
                board = buildMap(self.e1, self.empire, self.e2)
                unit_loc = units_Map(self.e1, self.empire, self.e2)

            elif self.e1.name == 'Carthage' and self.empire.name == 'Rome':
                board = buildMap(self.empire, self.e1, self.e2)
                unit_loc = units_Map(self.empire, self.e1, self.e2)
            else:
                board = buildMap(self.e1, self.e2, self.empire)
                unit_loc = units_Map(self.e1, self.e2, self.empire)

            """Grahpical implementation with unpacking of the decision, with version set to true"""
            self.unpack(empire_decision[1], board, locations, unit_loc, self.e1, self.empire, self.e2, True)
        # switch to next empire
        return self.empire2_play()

    """ENEMY EMPIRE 2 TURN"""

    def empire2_play(self):
        # check if AI empire 2 has been defeated
        self.check_defeat(self.e2)
        if self.e2.state != 'Defeat':
            # check for victory
            self.checkWin()
            # update empire's resources
            self.e2.update_treasury()
            self.e2.update_manpower()
            self.e2.update_stability()
            # reset unit scores for empire 1 for clean minimax run (already this empire's units and player's have been reset in empire1_play()
            for unit in self.e1.units:
                unit.score = 0
            """INIT OF THE CLONE EMPIRES FOR MINIMAX RUN"""
            prop1 = self.copy_empire(self.e2)
            prop2 = self.copy_empire(self.e1)
            prop3 = self.copy_empire(self.empire)
            """CLONE BOARD AND UNIT LOCATIONS BOARD INIT"""
            if self.e2.name == 'Egypt' and self.empire.name == 'Rome':
                board = buildMap(prop3, prop2, prop1)
                unit_loc = units_Map(prop3, prop2, prop1)

            elif self.e2.name == 'Egypt' and self.empire.name == 'Carthage':
                board = buildMap(prop2, prop3, prop1)
                unit_loc = units_Map(prop2, prop3, prop1)

            else:
                board = buildMap(prop2, prop1, prop3)
                unit_loc = units_Map(prop2, prop1, prop3)

            self.minimaxed = prop1  # MINIMAXED EMPIRE - SELF
            '''THE MINIMAX RUN - the decision is received from it'''
            empire_decision = self.minimax(board, locations, unit_loc, prop1, prop2, prop3, 3, prop1, MIN, MAX, None)
            """CLONE BOARD AND UNIT LOCATIONS BOARD INIT - for graphical implementation"""
            if self.e2.name == 'Egypt' and self.empire.name == 'Rome':
                board = buildMap(self.empire, self.e1, self.e2)
                unit_loc = units_Map(self.empire, self.e1, self.e2)

            elif self.e2.name == 'Egypt' and self.empire.name == 'Carthage':
                board = buildMap(self.e1, self.empire, self.e2)
                unit_loc = units_Map(self.e1, self.empire, self.e2)
            else:
                board = buildMap(self.e1, self.e2, self.empire)
                unit_loc = units_Map(self.e1, self.e2, self.empire)
            """Grahpical implementation with unpacking of the decision, with version set to true"""
            self.unpack(empire_decision[1], board, locations, unit_loc, self.e2, self.e1, self.empire, True)

        # switch to next empire
        return self.player_play()

    '''==============================================AI-MINIMAX======================================================'''
    '''MINIMAX FUNCTION FUNCTION'''

    def minimax(self, board, topo_map, unit_locs, empire, empire2, empire3, depth, current_empire, alpha, beta, pack):
        """
        MINIMAX ALGORITHM :
        ------------------------------------------------------------------
        Minimax is a kind of backtracking algorithm that is used in decision making and game theory to find the
        optimal move for a player, assuming that your opponent also plays optimally. Every board state has a value
        associated with it. In regular Minimax algorithms, the is only one maximizer and minimizer. But since the game
        has 3 players, this minimax algorithm runs between the 3 empires, so the minimaxed empire is the maximizer and
        the other 2 are minimizers.
        In a given state if the maximizer has upper hand then, the score of the board will tend to be positive value.
        If the minimizer has the upper hand in that board state then it will tend to be some negative value. The values
        of the board are calculated by some heuristics which are unique for every
        type of game.

        ALPHA - BETA PRUNING FOR MINIMAX :
        ------------------------------------------------------------------
        Alpha-Beta pruning is  an optimization technique for minimax algorithm. It reduces the computation time by a
        huge factor. This allows us to search much faster and even go into deeper levels in the game tree. It cuts off
        branches in the game tree which need not be searched because there already exists a better move available. It is
        called Alpha-Beta pruning because it passes 2 extra parameters in the minimax function, namely alpha and beta.
        Alpha is the best value that the maximizer currently can guarantee at that level or above.
        Beta is the best value that the minimizer currently can guarantee at that level or above.
        -------------------------------------------------------------------
        :param board: Empire 2d list board locations and terrain values
        :param topo_map:  2d list board with only terrain values
        :param unit_locs: 2d list board with unit locations with unique values for each empire
        :param empire: empire currently doing its turn
        :param empire2: rival empire
        :param empire3: rival empire
        :param depth: target depth - the bigger the depth, the more possible futures the MAXIMIZER can see (increases AI effieciency)
        :param current_empire: current empire - to switch between empires
        :param alpha: alpha value - initial -INF
        :param beta: beta value  - inital +INF
        :param pack: current decisions pack - None on the start since no pack was created yet
        :return: returns the best value and the pack associated with the best value
        """
        possible_decisions = [[1, 2], [3], [4, 5], [6], [7]]  # possible decisions (numbers represent functions- see unpack)
        possible_moves = list(itertools.product(*possible_decisions))  # possible moves generated (4 per empire / depth)
        optimal_decision = float("inf")  # optimal decision from the minimax function
        # stop condition - if bottom depth reached, or game is over or empire has capitulated already
        if depth == 0 or self.checkWin() or empire.state == 'Defeat':
            # since the worst score can for either empire is defeat then the score return will be inf or -inf
            # depending if the empire is maximizer/ minimizer, else continue regular scoring
            if empire.state == 'Defeat':
                if empire != self.minimaxed:
                    return MAX
                else:
                    return MIN
            else:
                return self.evaluate(board, empire, empire2, empire3), pack

        """
        Each empire processes it's own turn starting from the minimaxed empire, then rival empire 1, 
        rival empire2 and vise versa. Each empire turn begins with defining bestVal - if the empire is the MAXIMIZER, 
        bestVal will be MIN (and slowly rise to max value), else bestVal will be MAX so the maximizer gets min 
        possible value. Then the empire runs in a for loop across all possible decision packs in that turn, 
        unpacks it (changing the clone board) and moves it to next empire for minimax. Once the backtracking recursion
        starts, the value is returned to the empire and bestValue is compared to the return value together with best 
        turn.
        Now the alpha beta pruning : 
            if there empire is MAXIMIZER - alpha is calculated, else beta is calculated. Then checked if alpha>= beta
            - already exists a better value for the empire at that level then continue to next level and return bestVal
            and associated decision pack to the depth level.
        """

        # empire e1 clone turn
        if current_empire.name == self.e1.name:
            if self.minimaxed.name == self.e1.name:
                bestVal = MIN
            else:
                bestVal = MAX
            # loop through possible decisions
            for decision_pack in possible_moves:
                result = self.unpack(decision_pack, board, topo_map, unit_locs, empire, empire2, empire3, False)
                for unit in current_empire.units:
                    unit.score = 0
                value = self.minimax(copy.deepcopy(result), topo_map, copy.deepcopy(unit_locs),
                                     self.copy_empire(empire2), self.copy_empire(empire), self.copy_empire(empire3),
                                     depth - 1, self.copy_empire(empire2), alpha, beta, decision_pack)
                if self.minimaxed.name == self.e1.name:
                    if bestVal < value[0]:
                        bestVal = value[0]
                        optimal_decision = value[1]
                    # alpha beta pruning
                    alpha = max(alpha, bestVal)
                    if beta <= alpha:
                        break
                else:
                    if bestVal > value[0]:
                        bestVal = value[0]
                        optimal_decision = value[1]
                    # alpha beta pruning
                    beta = min(beta, bestVal)
                    if beta <= alpha:
                        break

            return bestVal, optimal_decision
        # empire player empire clone turn (always minimizer - minimax runs only for AI)
        elif current_empire.name == self.empire.name:
            bestVal = MAX
            # loop through possible decisions
            for decision_pack in possible_moves:
                result = self.unpack(decision_pack, board, topo_map, unit_locs, empire, empire2, empire3, False)
                for unit in current_empire.units:
                    unit.score = 0
                value = self.minimax(copy.deepcopy(result), topo_map, copy.deepcopy(unit_locs),
                                     self.copy_empire(empire3), self.copy_empire(empire2), self.copy_empire(empire),
                                     depth - 1, self.copy_empire(empire3), alpha, beta, decision_pack)
                if bestVal > value[0]:
                    bestVal = value[0]
                    optimal_decision = value[1]
                # alpha beta pruning
                beta = min(beta, bestVal)
                if beta <= alpha:
                    break
            return bestVal, optimal_decision
        # empire e2 clone turn
        elif current_empire.name == self.e2.name:
            if self.minimaxed.name == self.e2.name:
                bestVal = MIN
            else:
                bestVal = MAX

            # loop through possible decisions
            for decision_pack in possible_moves:
                result = self.unpack(decision_pack, board, topo_map, unit_locs, empire, empire2, empire3, False)
                for unit in current_empire.units:
                    unit.score = 0
                value = self.minimax(copy.deepcopy(result), topo_map, copy.deepcopy(unit_locs),
                                     self.copy_empire(empire2), self.copy_empire(empire3), self.copy_empire(empire),
                                     depth - 1, self.copy_empire(empire2), alpha, beta, decision_pack)
                if self.minimaxed.name == self.e2.name:
                    if bestVal < value[0]:
                        bestVal = value[0]
                        optimal_decision = value[1]
                    # alpha beta pruning
                    alpha = max(alpha, bestVal)
                    if beta <= alpha:
                        break
                else:
                    if bestVal > value[0]:
                        bestVal = value[0]
                        optimal_decision = value[1]
                    # alpha beta pruning
                    beta = min(beta, bestVal)
                    if beta <= alpha:
                        break
            return bestVal, optimal_decision

    '''UNPACK THE DECISION PACK FUNCTION'''

    def unpack(self, list, board, topo_map, unit_locs, empire, empire2, empire3, version):
        """
        Function Method :
            Function that receives a list of numbers that represent functions (1- 7) and activate the
            adjacent functions. In the end the updated from the functions board is returned
            =========================================================================================
        :param list: list of function numbers
        :param board: 2d list of the empires locations
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        :return: updated board
        """
        for i in list:
            stance = None # stance is whether empire should stay defensive or offensive in case of war, none if peace
            # PEACE TIME
            if empire.state == 'Peace':
                if i == 1:  # soldier capture territory
                    self.capture(board, topo_map, unit_locs, empire, empire2, empire3, stance, version)
                if i == 2:  # soldier reinforce important territories
                    self.reinforce(board, topo_map, empire, unit_locs, empire2, empire3, version)
                if i == 3: # worker general function
                    self.worker_action(board, topo_map, unit_locs, empire, empire2, empire3, None, stance, version)
                if i == 4: # warship general function
                    self.warship_action(board, unit_locs, empire, empire2, empire3, None, stance, version)
                if i == 5: # warship patrol function
                    self.patrol(board, unit_locs, empire, version)
                if i == 6: # peace time general function - diplomacy
                    if empire.name == self.e2.name:
                        self.diplomacy(empire, empire3, empire2, version)
                    else:
                        self.diplomacy(empire, empire2, empire3, version)
                if i == 7: # general function - add units
                    self.add_units(unit_locs, empire, empire2, empire3, None, version)
            # WAR TIME
            elif empire.state == 'War':
                # enemy empire calculation + stance
                enemy_empire = None
                if empire2.state == 'War':
                    stance = empire.army >= empire2.army
                    enemy_empire = empire2
                elif empire3.state == 'War':
                    stance = empire.army >= empire3.army
                    enemy_empire = empire3

                if i == 1:  # soldier capture territory
                    self.capture(board, topo_map, unit_locs, empire, empire2, empire3, stance, version)
                if i == 2:  # soldier reinforce important territories
                    self.reinforce(board, topo_map, empire, unit_locs, empire2, empire3, version)
                if i == 3: # worker general function
                    self.worker_action(board, topo_map, unit_locs, empire, empire2, empire3, enemy_empire, stance,
                                       version)
                if i == 4: # warship general function
                    self.warship_action(board, unit_locs, empire, empire2, empire3, enemy_empire, stance, version)
                if i == 5: # warship patrol function
                    self.patrol(board, unit_locs, empire, version)
                if i == 6: # war time general function - engage
                    self.engage(unit_locs, empire, enemy_empire, version, topo_map)
                if i == 7: # general function - add units
                    self.add_units(unit_locs, empire, empire2, empire3, enemy_empire, version)

        return board

    '''EVALUATE BOARD FUNCTION'''

    def evaluate(self, board, empire, empire2, empire3):
        """
        Function Method :
            The basic idea behind the evaluation function is to give a high value for a board if
            maximizers turn or a low value for the board if minimizers turn.
            ====================================================================================
        :param board: board
        :param empire: empire 1            *one of them is MAXIMIZER and the others are MINIMIZERS
        :param empire2: empire 2
        :param empire3: empire 3
        :return: value of the current board
        """
        score = 0  # score of the board
        score += len(empire.units) * 10 - len(empire2.units) * 5 - len(
            empire3.units) * 5  # score updated with units ratio
        score += empire.tiles * 2 - empire2.tiles - empire3.tiles  # score updated with tiles ratio
        # punish for low stability
        if empire.stability < 0:
            score -= 50
        # run through empire unit positions relative to the empire's state and availibilty of good tiles around / enemies
        for unit in empire.units:
            for i in range(unit.loc[0] - 1, unit.loc[0] + 2):
                for j in range(unit.loc[1] - 1, unit.loc[1] + 2):
                    if 0 <= i < 48 and 0 <= j < 70:
                        if empire.state == 'War':
                            if empire2.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire2.tile_arr[i][
                                    j] == 'O':
                                    score += 10
                                else:
                                    score -= 10
                            if empire3.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire3.tile_arr[i][
                                    j] == 'O':
                                    score += 10
                                else:
                                    score -= 10
                        else:
                            if type(unit) == Empire_Unit:
                                if (board[i][j] == 'g' or board[i][j] == 'd') and empire2.tile_arr[i][j] != 'O' and \
                                        empire3.tile_arr[i][j] != 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score += 10
                                    else:
                                        score += 1


                            elif type(unit) == Empire_Worker:
                                if empire.tile_arr[i][j] == 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score += 10
                                    else:
                                        score += 1

        for unit in empire2.units:
            for i in range(unit.loc[0] - 1, unit.loc[0] + 2):
                for j in range(unit.loc[1] - 1, unit.loc[1] + 2):
                    if 0 <= i < 48 and 0 <= j < 70:
                        if empire2.state == 'War':
                            if empire.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire.tile_arr[i][
                                    j] == 'O':
                                    score -= 10
                                else:
                                    score += 10
                            if empire3.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire3.tile_arr[i][
                                    j] == 'O':
                                    score -= 10
                                else:
                                    score += 10
                        else:
                            if type(unit) == Empire_Unit:
                                if (board[i][j] == 'g' or board[i][j] == 'd') and empire.tile_arr[i][j] != 'O' and \
                                        empire3.tile_arr[i][j] != 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score -= 10
                                    else:
                                        score -= 1
                                else:
                                    score += 1

                            elif type(unit) == Empire_Worker:
                                if empire2.tile_arr[i][j] == 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score -= 10
                                    else:
                                        score -= 1
                                else:
                                    score += 1

        for unit in empire3.units:
            for i in range(unit.loc[0] - 1, unit.loc[0] + 2):
                for j in range(unit.loc[1] - 1, unit.loc[1] + 2):
                    if 0 <= i < 48 and 0 <= j < 70:
                        if empire3.state == 'War':
                            if empire2.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire2.tile_arr[i][
                                    j] == 'O':
                                    score -= 10
                                else:
                                    score += 10
                            if empire.state == 'War':
                                if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and empire.tile_arr[i][
                                    j] == 'O':
                                    score -= 10
                                else:
                                    score += 10
                        else:
                            if type(unit) == Empire_Unit:
                                if (board[i][j] == 'g' or board[i][j] == 'd') and empire2.tile_arr[i][j] != 'O' and \
                                        empire.tile_arr[i][j] != 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score -= 10
                                    else:
                                        score -= 1
                                else:
                                    score += 1

                            elif type(unit) == Empire_Worker:
                                if empire3.tile_arr[i][j] == 'O':
                                    if i == unit.loc[0] and j == unit.loc[1]:
                                        score -= 10
                                    else:
                                        score -= 1
                                else:
                                    score += 1

        if empire.name != self.minimaxed.name:
            # since the entire calculation for score above is done for the MAXIMIZER then if current empire isn't
            # maximizer then we should set score by -1 since now the score reflects MINIMIZER values
            score = score * (-1)

        return score

    '''SOLDIER CAPTURE FUNCTION'''

    def capture(self, board, topo_map, unit_locs, empire, empire2, empire3, stance, version):
        """
        Function Method :
            The function runs through all empires soldiers and makes
            them capture territories / head to unclaimed  territories
            =========================================================
        :param board: 2d list of the empires locations
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param stance : stance - bool representing current empire stance - defensive / offensive or none
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # loop through all emprie units
        for unit in empire.units:
            # case unit is soldier (only these needed)
            if type(unit) == Empire_Unit and unit.name == empire.name:
                # while unit score < 3
                while unit.score < 3:
                    # case peace
                    if empire.state == 'Peace':
                        # if unit stands on unclaimed land
                        if board[unit.loc[0]][unit.loc[1]] != empire.name[0] and board[unit.loc[0]][unit.loc[1]] != \
                                empire2.name[0] and board[unit.loc[0]][unit.loc[1]] != empire3.name[0]:
                            # update empire stats
                            board[unit.loc[0]][unit.loc[1]] = empire.name[0]
                            empire.tiles += 1
                            empire.add_locations(unit.loc[1], unit.loc[0])
                            board[unit.loc[0]][unit.loc[1]] = empire.name[0]
                            unit.score += 1
                            # graphical version
                            if version:
                                for hex in self.b.children:
                                    if type(hex) == Empire_HexTile and hex.loc == unit.loc:
                                        if empire.name == 'Rome':
                                            hex.type = "Roman"
                                            if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                hex.source = os.path.join('assets', 'images', '35_rome_hex_city.png')
                                            else:
                                                hex.source = os.path.join('assets', 'images', '35_rome_hex.png')

                                                hex.type = "Roman"

                                        elif empire.name == 'Carthage':
                                            hex.type = "Carthaginian"
                                            if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                hex.source = os.path.join('assets', 'images',
                                                                          '36_carthage_hex_city.png')
                                            else:
                                                hex.source = os.path.join('assets', 'images', '36_carthage_hex.png')

                                            hex.type = "Carthaginian"

                                        elif empire.name == 'Egypt':
                                            hex.type = "Egyptian"
                                            if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                hex.source = os.path.join('assets', 'images', '37_egypt_hex_city.png')
                                            else:
                                                hex.source = os.path.join('assets', 'images', '37_egypt_hex.png')

                                            hex.type = "Egyptian"
                                        break
                        else: # else - find closest tile to capture
                            min_dis = float("inf") # min distance
                            curr_loc = unit.loc
                            # search in range 10 around the unit
                            for i in range(unit.loc[0] - 10, unit.loc[0] + 10):
                                for j in range(unit.loc[1] - 10, unit.loc[1] + 10):
                                    if 48 > i >= 0 <= j < 70 and unit.loc != (i, j) and board[i][j] != empire.name[
                                        0] and unit_locs[i][j] == 1 and topo_map[i][j] != 'w' and topo_map[i][
                                        j] != 'm' and empire2.tile_arr[i][j] != 'O' and empire3.tile_arr[i][j] != 'O':
                                        if ((i, j) in islands and unit.loc in islands) or (
                                                (i, j) not in islands and unit.loc not in islands):
                                            dis = math.sqrt(((unit.loc[0] - i) ** 2) + ((unit.loc[1] - j) ** 2))
                                            if dis < min_dis:
                                                min_dis = dis
                                                curr_loc = (i, j)
                            # build path to the target location using ASTAR
                            path = astar(topo_map, board, unit.loc, curr_loc, empire2, empire3, stance, 'land')
                            if path != None and len(path) > 1: # if there is path - change unit location to the first tile in the path
                                # update unit list and unit location and unit score
                                unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                if version: # graphical implementation
                                    if path[1][1] % 2 == 0:
                                        unit.pos = (7 + path[1][1] * 45, (path[1][0] + 1) * 50 + 8)
                                    else:
                                        unit.pos = (7 + path[1][1] * 45, path[1][0] * 50 + 65 / 2)
                                    Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                    for hex in self.b.children:
                                        if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                            hex.occupied = False
                                        if type(hex) == Empire_HexTile and hex.loc[0] == path[1][0] and hex.loc[1] == \
                                                path[1][1] and hex.occupied == False:
                                            hex.occupied = True

                                unit.loc = path[1]
                                unit_locs[path[1][0]][path[1][1]] = empire.name[0] + 'U'
                                unit.score += 1
                            else:
                                # wander around - prevent units sitting doing nothing
                                # random location around the unit
                                if unit.loc[1] % 2 == 0:
                                    x = random.randint(unit.loc[0], unit.loc[0] + 2)
                                    y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                    while x < 0 or x >= 48 or y < 0 or y >= 70 or (
                                            board[x][y] == 'w' or board[x][y] == 'm') or board[x][y] == empire2.name[
                                        0] or board[x][y] == empire3.name[0]:
                                        x = random.randint(unit.loc[0], unit.loc[0] + 2)
                                        y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)
                                else:
                                    x = random.randint(unit.loc[0] - 1, unit.loc[0] + 1)
                                    y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                    while x < 0 or x >= 48 or y < 0 or y >= 70 or (
                                            board[x][y] == 'w' or board[x][y] == 'm') or board[x][y] == empire2.name[
                                        0] or board[x][y] == empire3.name[0]:
                                        x = random.randint(unit.loc[0] - 1, unit.loc[0] + 1)
                                        y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                if version: # graphical implementation
                                    if x % 2 == 0:
                                        unit.pos = (7 + y * 45, (x + 1) * 50 + 8)
                                    else:
                                        unit.pos = (7 + y * 45, x * 50 + 65 / 2)
                                    Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                    for hex in self.b.children:
                                        if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                            hex.occupied = False
                                        if type(hex) == Empire_HexTile and hex.loc == (x, y) and hex.occupied == False:
                                            hex.occupied = True
                                # update unit list and unit location and unit score
                                unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                unit.loc = (x, y)
                                unit_locs[x][y] = empire.name[0] + 'U'
                                unit.score += 1
                    # case war
                    elif empire.state == 'War':
                        if stance: # if empire feels offensive - capture enemy territories
                            if board[unit.loc[0]][unit.loc[1]] != empire.name[0]: # if territory is controlled by the emprire
                                # update empire stats after capture
                                board[unit.loc[0]][unit.loc[1]] = empire.name[0]
                                empire.tiles += 1
                                empire.add_locations(unit.loc[1], unit.loc[0])
                                board[unit.loc[0]][unit.loc[1]] = empire.name[0]
                                unit.score += 1
                                if empire2.state == 'War' and board[unit.loc[0]][unit.loc[1]] == empire2.name[0]:
                                    empire2.tile_arr[unit.loc[0]][unit.loc[1]] = 1
                                    empire2.tiles -= 1
                                    if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                        empire2.cities.remove(unit.loc[0], unit.loc[1])
                                    if unit.loc == empire2.capital:
                                        empire2.capital_captured = True
                                if empire3.state == 'War' and board[unit.loc[0]][unit.loc[1]] == empire3.name[0]:
                                    empire3.tile_arr[unit.loc[0]][unit.loc[1]] = 1
                                    empire3.tiles -= 1
                                    if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                        empire3.cities.remove(unit.loc[0], unit.loc[1])
                                    if unit.loc == empire3.capital:
                                        empire3.capital_captured = True
                                # version is graphical
                                if version:
                                    for hex in self.b.children:
                                        if type(hex) == Empire_HexTile and hex.loc == unit.loc:
                                            if empire.name == 'Rome':
                                                hex.type = "Roman"
                                                if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                    hex.source = os.path.join('assets', 'images',
                                                                              '35_rome_hex_city.png')
                                                else:
                                                    hex.source = os.path.join('assets', 'images', '35_rome_hex.png')

                                                    hex.type = "Roman"

                                            elif empire.name == 'Carthage':
                                                hex.type = "Carthaginian"
                                                if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                    hex.source = os.path.join('assets', 'images',
                                                                              '36_carthage_hex_city.png')
                                                else:
                                                    hex.source = os.path.join('assets', 'images', '36_carthage_hex.png')

                                                hex.type = "Carthaginian"

                                            elif empire.name == 'Egypt':
                                                hex.type = "Egyptian"
                                                if locations[unit.loc[0]][unit.loc[1]] == 'c':
                                                    hex.source = os.path.join('assets', 'images',
                                                                              '37_egypt_hex_city.png')
                                                else:
                                                    hex.source = os.path.join('assets', 'images', '37_egypt_hex.png')

                                                hex.type = "Egyptian"
                                            break

                            else: # find the closest enemy tiles / unclaimed territory
                                min_dis = float("inf") # min distance
                                curr_loc = unit.loc
                                # run through range 10 around the unit
                                for i in range(unit.loc[0] - 10, unit.loc[0] + 10):
                                    for j in range(unit.loc[1] - 10, unit.loc[1] + 10):
                                        if i >= 0 and i < 48 and j >= 0 and j < 70 and unit.loc != (i, j) and board[i][
                                            j] != empire.name[0] and unit_locs[i][j] == 1 and topo_map[i][j] != 'w' and \
                                                topo_map[i][j] != 'm' :
                                            if ((i, j) in islands and unit.loc in islands) or (
                                                    (i, j) not in islands and unit.loc not in islands):
                                                dis = math.sqrt(((unit.loc[0] - i) ** 2) + ((unit.loc[1] - j) ** 2))
                                                if dis < min_dis:
                                                    min_dis = dis
                                                    curr_loc = (i, j)
                                # build path to the target location using ASTAR
                                path = astar(topo_map, board, unit.loc, curr_loc, empire2, empire3, stance, 'land')
                                # if there is path - update unit location with the first next tile in the path
                                if path != None and len(path) > 1:
                                    unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                    if version: # graphical implementation
                                        if path[1][1] % 2 == 0:
                                            unit.pos = (7 + path[1][1] * 45, (path[1][0] + 1) * 50 + 8)
                                        else:
                                            unit.pos = (7 + path[1][1] * 45, path[1][0] * 50 + 65 / 2)
                                        Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                        for hex in self.b.children:
                                            if type(
                                                    hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                                hex.occupied = False
                                            if type(hex) == Empire_HexTile and hex.loc[0] == path[1][0] and hex.loc[
                                                1] == path[1][1] and hex.occupied == False:
                                                hex.occupied = True

                                    unit.loc = path[1]
                                    unit_locs[path[1][0]][path[1][1]] = empire.name[0] + 'U'
                                    unit.score += 1
                                else:
                                    # wander around - prevent units sitting doing nothing
                                    # random location around the unit
                                    if unit.loc[1] % 2 == 0:
                                        x = random.randint(unit.loc[0], unit.loc[0] + 2)
                                        y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                        while x < 0 or x >= 48 or y < 0 or y >= 70 or board[x][y] == 'w' or board[x][
                                            y] == 'm':
                                            x = random.randint(unit.loc[0], unit.loc[0] + 2)
                                            y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)
                                    else:
                                        x = random.randint(unit.loc[0] - 1, unit.loc[0] + 1)
                                        y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                        while x < 0 or x >= 48 or y < 0 or y >= 70 or board[x][y] == 'w' or board[x][
                                            y] == 'm':
                                            x = random.randint(unit.loc[0] - 1, unit.loc[0] + 1)
                                            y = random.randint(unit.loc[1] - 1, unit.loc[1] + 2)

                                    if version:
                                        if x % 2 == 0:
                                            unit.pos = (7 + y * 45, (x + 1) * 50 + 8)
                                        else:
                                            unit.pos = (7 + y * 45, x * 50 + 65 / 2)
                                        Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                        for hex in self.b.children:
                                            if type(
                                                    hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied:
                                                hex.occupied = False
                                            if type(hex) == Empire_HexTile and hex.loc == (
                                                    x, y) and hex.occupied == False:
                                                hex.occupied = True
                                    # update unit list and unit location and unit score
                                    unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                    unit.loc = (x, y)
                                    unit_locs[x][y] = empire.name[0] + 'U'
                                    unit.score += 1

                        else: # if stance is false then capture function is irrelevant and empire should garrison
                              # soldier units  in important locations
                            return self.reinforce(board, topo_map, empire, unit_locs, empire2, empire3, version)

    '''SOLDIER REINFORCE FUNCTION'''

    def reinforce(self, board, topo_map, empire, unit_locs, empire2, empire3, version):
        """
        Function Method :
            The function runs through all empires soldiers and makes them reinforce important territories
            =============================================================================================
        :param board: 2d list of the empires locations
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        priority_locs = [] # list with priority locations list
        # loop through board - search for border tiles
        for x in range(48):
            for y in range(70):
                # if tile isnt empire controlled
                if board[x][y] != empire.name[0] and (topo_map[x][y] == 'g' or topo_map[x][y] == 'd'):
                    # run around it and search for empire tiles - if there is, append them and stop looping
                    if y % 2 == 0:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                            tile = (x + new_position[0], y + new_position[1])
                            if 0 <= tile[0] < 48 and 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == empire.name[0] and \
                                    unit_locs[tile[0]][tile[1]] == 1:
                                priority_locs.append(tile)
                                break
                    else:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                            tile = (x + new_position[0], y + new_position[1])
                            if 0 <= tile[0] < 48 and 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == empire.name[0] and \
                                    unit_locs[tile[0]][tile[1]] == 1:
                                priority_locs.append(tile)
                                break

        priority_locs = list(dict.fromkeys(priority_locs)) # remove duplicates from priority locs
        # loop through soldiers
        for unit in empire.units:
            if type(unit) == Empire_Unit and unit.name == empire.name:
                # find min distance - closest tile to current unit location
                min_dis = float("inf")
                curr_loc = unit.loc
                # loop through priority locs
                for loc in priority_locs:
                    # check if location is island and soldier is on island or locations isnt island and soldier isnt on island
                    if (loc in islands and unit.loc in islands) or (loc not in islands and unit.loc not in islands):
                        dis = math.sqrt(((unit.loc[0] - loc[0]) ** 2) + ((unit.loc[1] - loc[1]) ** 2))
                        if dis < min_dis:
                            min_dis = dis
                            curr_loc = loc

                if len(priority_locs) > 0 and curr_loc in priority_locs:
                    priority_locs.remove(curr_loc)
                # build path to priority location
                path = astar(topo_map, board, unit.loc, curr_loc, empire2, empire3, None, 'land')
                # if there is path
                if path != None and len(path) > 1:
                    # update unit_loc map and unit location
                    unit_locs[unit.loc[0]][unit.loc[1]] = 1
                    if version: # graphical implementation
                        if path[1][1] % 2 == 0:
                            unit.pos = (7 + path[1][1] * 45, (path[1][0] + 1) * 50 + 8)
                        else:
                            unit.pos = (7 + path[1][1] * 45, path[1][0] * 50 + 65 / 2)
                        Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                        for hex in self.b.children:
                            if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                hex.occupied = False
                            if type(hex) == Empire_HexTile and hex.loc == path[1] and hex.occupied == False:
                                hex.occupied = True

                    unit.loc = path[1]
                    unit_locs[path[1][0]][path[1][1]] = empire.name[0] + 'U'
                unit.score += 3 # update unit score

    '''WORKER GENERAL FUNCTION'''

    def worker_action(self, board, topo_map, unit_locs, empire, empire2, empire3, enemy_empire, stance, version):
        """
        Function Method :
            The function runs through all empires workers and makes them construct farms (to increase empire income)
            or search for closest tiles on which there can be built another farm
            ========================================================================================================
        :param board: 2d list of the empires locations
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param enemy_empire:
        :param stance: stance - bool representing current empire stance - defensive / offensive or none
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # loop throug empire units
        for unit in empire.units:
            if type(unit) == Empire_Worker and unit.name == empire.name:
                while unit.score < 3:
                    enemy_close = False # if enemy is near worker unit
                    enemy_loc = (0, 0) # enemy's location
                    #case it is war : search for nearby enemy units
                    if empire.state == 'War':
                        for i in range(unit.loc[0] - 1, unit.loc[0] + 2):
                            for j in range(unit.loc[1] - 1, unit.loc[1] + 2):
                                if 0 <= i < 48 and 0 <= j < 70:
                                    # check unit_locs based on empire name
                                    if enemy_empire.name == 'Rome':
                                        if unit_locs[i][j] == 'RS' or unit_locs[i][j] == 'RU' or unit_locs[i][
                                            j] == 'RW':
                                            enemy_close = True
                                            enemy_loc = (i, j)
                                            break

                                    elif enemy_empire.name == 'Carthage':
                                        if unit_locs[i][j] == 'CS' or unit_locs[i][j] == 'CU' or unit_locs[i][
                                            j] == 'CW':
                                            enemy_close = True
                                            enemy_loc = (i, j)
                                            break

                                    elif enemy_empire.name == 'Egypt':
                                        if unit_locs[i][j] == 'ES' or unit_locs[i][j] == 'EU' or unit_locs[i][
                                            j] == 'EW':
                                            enemy_close = True
                                            enemy_loc = (i, j)
                                            break

                    # if stance is none or true or there is no enemy around - do usual stuff
                    if stance == None or stance or (stance == False and enemy_close == False):
                        # check if unit is standing on tile that can be built upon
                        if board[unit.loc[0]][unit.loc[1]] == empire.name[0] and empire.farm_locs[unit.loc[0]][
                            unit.loc[1]] != 'O' and topo_map[unit.loc[0]][unit.loc[1]] != 'c':
                            # update empire unit score and empire stats
                            empire.farm_locs[unit.loc[0]][unit.loc[1]] = 'O'
                            empire.farms += 1
                            unit.score += 1
                            # graphical implementation
                            if version:
                                for hex in self.b.children:
                                    if type(hex) == Empire_HexTile and unit.loc == hex.loc:
                                        hex.source = os.path.join('assets', 'images', 'grass_hex.png')
                                        break

                        else:  # search for closest tile with no farm and is controlled by empire
                            min_dis = float("inf")
                            curr_loc = unit.loc
                            for i in range(unit.loc[0] - 5, unit.loc[0] + 5):
                                for j in range(unit.loc[1] - 5, unit.loc[1] + 5):
                                    if 0 <= i < 48 and 0 <= j < 70:
                                        if (i, j) != unit.loc and board[i][j] == empire.name[0] and empire.farm_locs[i][
                                            j] != 'O' and topo_map[i][j] != 'w' and topo_map[i][j] != 'm' and \
                                                unit_locs[i][j] == 1:
                                            if ((i, j) in islands and unit.loc in islands) or (
                                                    (i, j) not in islands and unit.loc not in islands):
                                                dis = math.sqrt(((unit.loc[0] - i) ** 2) + ((unit.loc[1] - j) ** 2))
                                                if dis < min_dis:
                                                    min_dis = dis
                                                    curr_loc = (i, j)
                            # build path to it
                            path = astar(topo_map, board, unit.loc, curr_loc, empire2, empire3, stance, 'land')
                            # if there is path - go to it
                            if path != None and len(path) > 1:
                                # update unit location and unit_locs board
                                unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                if version: # graphical implementation
                                    if path[1][1] % 2 == 0:
                                        unit.pos = (7 + path[1][1] * 45, (path[1][0] + 1) * 50 + 8)
                                    else:
                                        unit.pos = (7 + path[1][1] * 45, path[1][0] * 50 + 65 / 2)
                                    Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)

                                    for hex in self.b.children:
                                        if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                            hex.occupied = False
                                        if type(hex) == Empire_HexTile and hex.loc[0] == path[1][0] and hex.loc[1] == \
                                                path[1][1] and hex.occupied == False:
                                            hex.occupied = True
                                unit.loc = path[1]
                                unit_locs[path[1][0]][path[1][1]] = empire.name[0] + 'W'
                            unit.score += 1 # update score

                    # case there is enemy nearby
                    elif enemy_close:
                        # find the maximum distance from nearby enemy
                        max_dis = -float("inf")
                        curr_loc = unit.loc
                        # run through the tiles around the unit
                        if unit.loc[1] % 2 == 0:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                                dis = math.sqrt(((enemy_loc[0] - tile[0]) ** 2) + ((enemy_loc[1] - tile[1]) ** 2))

                                if dis > max_dis and topo_map[tile[0]][tile[1]] != 'w' and topo_map[tile[0]][
                                    tile[1]] != 'm':
                                    max_dis = dis
                                    curr_loc = tile
                        else:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                                dis = math.sqrt(((enemy_loc[0] - tile[0]) ** 2) + ((enemy_loc[1] - tile[1]) ** 2))
                                if dis > max_dis and topo_map[tile[0]][tile[1]] != 'w' and topo_map[tile[0]][
                                    tile[1]] != 'm':
                                    max_dis = dis
                                    curr_loc = tile

                        # if found a tile that isnt current unit location -> go to it
                        if curr_loc != unit.loc:
                            # update unit_locs and unit location
                            unit_locs[unit.loc[0]][unit.loc[1]] = 1
                            if version: # graphical implementation
                                if curr_loc[1] % 2 == 0:
                                    unit.pos = (7 + curr_loc[1] * 45, (curr_loc[0] + 1) * 50 + 8)
                                else:
                                    unit.pos = (7 + curr_loc[1] * 45, curr_loc[0] * 50 + 65 / 2)
                                Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                for hex in self.b.children:
                                    if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                        hex.occupied = False
                                    if type(hex) == Empire_HexTile and hex.loc[0] == curr_loc[0] and hex.loc[1] == \
                                            curr_loc[1] and hex.occupied == False:
                                        hex.occupied = True

                            unit.loc = curr_loc
                            unit_locs[unit.loc[0]][unit.loc[1]] = empire.name[0] + 'W'
                        unit.score += 1

    '''WARSHIP PATROL FUNCTION'''

    def patrol(self, board, unit_locs, empire, version):
        """
        Function Method :
            The function runs through all empires warships and makes them patrol waters near empire's shore
            ===============================================================================================
        :param board: 2d list of the empires locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # loop through empire warship units
        for unit in empire.units:
            if type(unit) == Empire_Warship and unit.name == empire.name:
                while unit.score < 3:
                    legal_moves = [] # legal moves - where the ship can go
                    # loop through surrounding the unit tiles and append tiles that are sea or water pass
                    if unit.loc[1] % 2 == 0:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                            tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                            if tile[0] >= 0 and tile[0] < 48 and tile[1] >= 0 and tile[1] < 70 and (
                                    board[tile[0]][tile[1]] == 'w' or board[tile[0]][
                                tile[1]] == 'p') and self.shore_is_close(tile[0], tile[1], board, empire):
                                legal_moves.append((tile[0], tile[1]))
                    else:
                        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                            tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                            if tile[0] >= 0 and tile[0] < 48 and tile[1] >= 0 and tile[1] < 70 and (
                                    board[tile[0]][tile[1]] == 'w' or board[tile[0]][
                                tile[1]] == 'p') and self.shore_is_close(tile[0], tile[1], board, empire):
                                legal_moves.append((tile[0], tile[1]))

                    legal_moves = list(dict.fromkeys(legal_moves)) # remove duplicates
                    # if unit can go somewhere
                    if len(legal_moves) > 0:
                        # get first move
                        ship_move = legal_moves.pop(0)
                        # update unit_locs board and unit location
                        unit_locs[unit.loc[0]][unit.loc[1]] = 1
                        if version: # graphical implementation
                            if ship_move[1] % 2 == 0:
                                unit.pos = (7 + ship_move[1] * 45, (ship_move[0] + 1) * 50 + 8)
                            else:
                                unit.pos = (7 + ship_move[1] * 45, ship_move[0] * 50 + 65 / 2)

                            Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                            for hex in self.b.children:
                                if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                    hex.occupied = False
                                if type(hex) == Empire_HexTile and hex.loc == ship_move and hex.occupied == False:
                                    hex.occupied = True

                        unit.loc = ship_move
                        unit_locs[unit.loc[0]][unit.loc[1]] = empire.name[0] + 'S'
                    unit.score += 1 # update score

    '''WARSHIP GENERAL FUNCTION'''

    def warship_action(self, board, unit_locs, empire, empire2, empire3, enemy_empire, stance, version):
        """
        Function Method :
            The function runs through all empires warships and makes them search for colonization targets. These
            targets can either cities that are not yet colonized with a shore line (case peace) or search for
            enemy empires shore cities and find paths to navaly invade them.
            ====================================================================================================
        :param board: 2d list of the empires locations
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param enemy_empire: enemy empire that empire is currently at war with
        :param stance: stance - bool representing current empire stance - defensive / offensive or none
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # colonization targets list
        colonization_targets = []
        # if empire is at peace - colonize shore cities that don't belong to anyone
        if stance is None:
            # loop through board and append cities with shore that aren't part of any empire
            for i in range(48):
                for j in range(70):
                    if board[i][j] == 'c':
                        if j % 2 == 0:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                                tile = (i + new_position[0], j + new_position[1])
                                if 48 > tile[0] >= 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == 'w' or \
                                        board[tile[0]][tile[1]] == 'p':
                                    colonization_targets.append(tile)
                                    break
                        else:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                                tile = (i + new_position[0], j + new_position[1])
                                if 48 > tile[0] >= 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == 'w' or \
                                        board[tile[0]][tile[1]] == 'p':
                                    colonization_targets.append(tile)
                                    break
        else: # else empire is currently at war with enemy_empire
            # loop through enemy empire cities, check if they have sea next to them and append them to targets list
            for city in enemy_empire.cities:
                if city[1] % 2 == 0:
                    for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                        tile = (city[0] + new_position[0], city[1] + new_position[1])
                        if 48 > tile[0] >= 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == 'w' or board[tile[0]][
                            tile[1]] == 'p':
                            colonization_targets.append(tile)
                            break
                else:
                    for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                        tile = (city[0] + new_position[0], city[1] + new_position[1])
                        if 48 > tile[0] >= 0 <= tile[1] < 70 and board[tile[0]][tile[1]] == 'w' or board[tile[0]][
                            tile[1]] == 'p':
                            colonization_targets.append(tile)
                            break

        colonization_targets = list(dict.fromkeys(colonization_targets)) # remove duplicates
        if len(colonization_targets) > 0: # check if list has targets
            # loop through warships while their score < 3
            for unit in empire.units:
                if type(unit) == Empire_Warship:
                    while unit.score < 3:
                        min_dis = float("inf") # min distance
                        curr_loc = unit.loc
                        # find target closest to unit location
                        for loc in colonization_targets:
                            dis = math.sqrt(((unit.loc[0] - loc[0]) ** 2) + ((unit.loc[1] - loc[1]) ** 2))
                            if dis < min_dis:
                                min_dis = dis
                                curr_loc = loc

                        if unit.score == 2 and min_dis > 2: # if unit score is 2 and it hasnt reached it destination,
                            # remove target location from list
                            colonization_targets.remove(curr_loc)
                        if min_dis < 2: # if unit has reached the location - > deploy unit to shore
                            colonization_targets.remove(curr_loc)
                            self.colonize(unit, unit_locs, empire, curr_loc, version) # activate colonize function
                        else: # else if unit has not reached the location has score is < 2
                            # build path to target
                            path = astar(locations, board, unit.loc, curr_loc, empire2, empire3, stance, 'sea')
                            # if path exists -> go to target
                            if path != None and curr_loc in colonization_targets:
                                # update unit location and unit_locs
                                unit_locs[unit.loc[0]][unit.loc[1]] = 1
                                if version: # graphical implementation
                                    if path[1][1] % 2 == 0:
                                        unit.pos = (7 + path[1][1] * 45, (path[1][0] + 1) * 50 + 8)
                                    else:
                                        unit.pos = (7 + path[1][1] * 45, path[1][0] * 50 + 65 / 2)
                                    Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                    for hex in self.b.children:
                                        if type(hex) == Empire_HexTile and hex.loc == unit.loc and hex.occupied == True:
                                            hex.occupied = False
                                        if type(hex) == Empire_HexTile and hex.loc[0] == path[1][0] and hex.loc[1] == \
                                                path[1][1] and hex.occupied == False:
                                            hex.occupied = True

                                unit.loc = path[1]
                                unit_locs[path[1][0]][path[1][1]] = empire.name[0] + 'S'
                            unit.score += 1 # update score

        else: # if there are no coloniztion target - > make ships patrol
            self.patrol(board, unit_locs, empire, version)

    '''PEACE TIME GENERAL FUNCTION - DIPLOMACY'''

    def diplomacy(self, empire, empire2, empire3, version):
        """
        Function Method :
            The function handles the diplomatic relations between the empires- proposal of agreements, declaring war
            / initiating peace. Note : empire2 will always be player empire unless empire is player empire.
            ========================================================================================================
        :param empire: current empire turn
        :param empire2: rival empire 1
        :param empire3: rival empire 2
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        empire.update_diplomacy(empire2, empire3) # update empire's diplomatic relations with the other 2 empires
        if empire2.state != 'Defeat':
            '''RELATIONS WITH EMPIRE 2'''
            if empire.dip1["relations"] > -100: # case relations with empire are not on the verge of war
                if empire.dip1["relations"] >= -10 and empire.dip1["trade agreement"] == False: # trade agreement
                    income = empire.treasury + empire.tiles * 10 + empire.farms * 50 + len(empire.cities) * 100 # empire's income
                    if (len(empire.rival_empires[0].cities) * 100 / income) * 10 > 10: # check if its worth having a
                        # trade agreement (trade deal isnt 10% of the empire's income
                        if version: # graphical implementation - popup decision for player
                            self.decisions_Popup(empire, "trade agreement")
                        else:
                            empire.dip1["trade agreement"] = True
                            empire2.dip1["trade agreement"] = True

                elif empire.dip1["relations"] >= 40 and self.supremacy(empire2, empire) and empire.dip1[
                    "non aggression"] != True: # non- aggression pact - based if the empire feels threatened by empire2
                    if version : # graphical implementation - popup decision for player
                        self.decisions_Popup(empire, "non aggression")
                    else:
                        empire.dip1["non aggression"] = True
                        empire2.dip1["non aggression"] = True

                elif empire.dip1["relations"] >= 70 and self.supremacy(empire, empire2) and empire.dip1[
                    "military access"] != True: # if empire feels superior to empire2 it will request military access
                    if version :# graphical implementation - popup decision for player
                        self.decisions_Popup(empire, "military access")
                    else:
                        empire.dip1["non aggression"] = True
                        empire2.dip1["non aggression"] = True

                elif empire.dip1["relations"] <= -80 and empire.dip1["war"] != True and empire.dip1[
                    "non aggression"] == False: # case war possiblity
                    if self.supremacy(empire, empire2): # if the empire feels eels superior to empire2 - > declares war
                        if version : # graphical implementation - popup decision for player
                            self.decisions_Popup(empire2, "War")
                        # set both empire's state to war
                        empire2.state = 'War'
                        empire2.dip1["trade agreement"] = False
                        empire2.dip1["non aggression"] = False
                        empire2.dip1["military access"] = False
                        empire2.dip1["war"] = True
                        empire.state = 'War'
                        empire.dip1["war"] = True
                        empire.dip1["trade agreement"] = False
                        empire.dip1["non aggression"] = False
                        empire.dip1["military access"] = False
                    elif empire.treasury >= 1000: # else if empire feels threatened by empire2 - > it will give it gold to sign non- aggression
                        if version: # graphical implementation - popup decision for player
                            self.decisions_Popup(empire, "appeasement")
                        empire2.treasury += 1000
                        empire.treasury -= 1000
                        empire.dip1["non aggression"] = True
                        empire2.dip1["non aggression"] = True

            elif empire.dip1["relations"] < -100 and empire.dip1["war"] != True and empire.dip1[
                "non aggression"] == False: # if empire and empire2 relations are at critical point -> war is imminent
                if version : # graphical implementation - popup decision for player
                    self.decisions_Popup(empire2, "War")
                empire2.state = 'War'
                empire2.dip1["trade agreement"] = False
                empire2.dip1["non aggression"] = False
                empire2.dip1["military access"] = False
                empire2.dip1["war"] = True
                empire.state = 'War'
                empire.dip1["war"] = True
                empire.dip1["trade agreement"] = False
                empire.dip1["non aggression"] = False
                empire.dip1["military access"] = False

        if empire3.state != 'Defeat':
            '''RELATIONS WITH EMPIRE 2'''
            if empire.dip2["relations"] > -100:  # case relations with empire are not on the verge of war
                if empire.dip2["relations"] >= -10 and empire.dip2["trade agreement"] == False:  # trade agreement
                    income = empire.treasury + empire.tiles * 10 + empire.farms * 50 + len(
                        empire.cities) * 100  # empire's income
                    if (len(empire.rival_empires[1].cities) * 100 / income) * 10 > 10:  # check if its worth having a
                        # trade agreement (trade deal isnt 10% of the empire's income
                        if version:  # graphical implementation - popup decision for player
                            self.decisions_Popup(empire, "trade agreement")
                        else:
                            empire.dip2["trade agreement"] = True
                            empire3.dip2["trade agreement"] = True

                elif empire.dip2["relations"] >= 40 and self.supremacy(empire2, empire) and empire.dip2[
                    "non aggression"] != True:  # non- aggression pact - based if the empire feels threatened by empire3
                    if version:  # graphical implementation - popup decision for player
                        self.decisions_Popup(empire, "non aggression")
                    else:
                        empire.dip2["non aggression"] = True
                        empire3.dip2["non aggression"] = True

                elif empire.dip2["relations"] >= 70 and self.supremacy(empire, empire2) and empire.dip2[
                    "military access"] != True:  # if empire feels superior to empire3 it will request military access
                    if version:  # graphical implementation - popup decision for player
                        self.decisions_Popup(empire, "military access")
                    else:
                        empire.dip2["non aggression"] = True
                        empire3.dip2["non aggression"] = True

                elif empire.dip2["relations"] <= -80 and empire.dip2["war"] != True and empire.dip2[
                    "non aggression"] == False:  # case war possiblity
                    if self.supremacy(empire, empire2):  # if the empire feels eels superior to empire3 - > declares war
                        if version:  # graphical implementation - popup decision for player
                            self.decisions_Popup(empire2, "War")
                        # set both empire's state to war
                        empire3.state = 'War'
                        empire3.dip2["trade agreement"] = False
                        empire3.dip2["non aggression"] = False
                        empire3.dip2["military access"] = False
                        empire3.dip2["war"] = True
                        empire.state = 'War'
                        empire.dip2["war"] = True
                        empire.dip2["trade agreement"] = False
                        empire.dip2["non aggression"] = False
                        empire.dip2["military access"] = False
                    elif empire.treasury >= 1000:  # else if empire feels threatened by empire3 - > it will give it gold to sign non- aggression
                        if version:  # graphical implementation - popup decision for player
                            self.decisions_Popup(empire, "appeasement")
                        empire3.treasury += 1000
                        empire.treasury -= 1000
                        empire.dip2["non aggression"] = True
                        empire2.dip2["non aggression"] = True

            elif empire.dip2["relations"] < -100 and empire.dip2["war"] != True and empire.dip2[
                "non aggression"] == False:  # if empire and empire3 relations are at critical point -> war is imminent
                if version:  # graphical implementation - popup decision for player
                    self.decisions_Popup(empire3, "War")
                # set both empire's state to war
                empire3.state = 'War'
                empire3.dip2["trade agreement"] = False
                empire3.dip2["non aggression"] = False
                empire3.dip2["military access"] = False
                empire3.dip2["war"] = True
                empire.state = 'War'
                empire.dip2["war"] = True
                empire.dip2["trade agreement"] = False
                empire.dip2["non aggression"] = False
                empire.dip2["military access"] = False

    '''WAR TIME GENERAL FUNCTION - ENGAGE'''

    def engage(self, unit_locs, empire, enemy, version, topo_map):
        """
        Function Method :
            Firstly :
            The function calculates the required manpower to add for each unit type - soldier or warship.
            It runs through empire's units adding manpower to each unit.
            Secondly :
            The function runs through all empires warships and soldiers and checks if there is an enemy unit around
            them. If there is one - they either engage it or retreat.
            =======================================================================================================
        :param topo_map: 2d list of the terrain locations
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param enemy_empire: enemy empire that empire is currently at war with
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # calculation of manpower for each ship
        manpower_for_ships = empire.manpower * int(empire.ships / (len(empire.units) - empire.workers))
        # calculation of manpower for each soldier
        manpower_for_soldiers = empire.manpower * int(empire.army / (len(empire.units) - empire.workers))
        # loop through empire units and add manpower to them
        for unit in empire.units:
            if type(unit) == Empire_Unit and empire.manpower >= manpower_for_soldiers:
                unit.power += manpower_for_soldiers
                empire.manpower -= manpower_for_soldiers

            elif type(unit) == Empire_Warship and empire.manpower >= manpower_for_ships:
                unit.power += manpower_for_ships
                empire.manpower -= manpower_for_ships
        # loop through units again checking for enemy targets
        for unit in empire.units:
            # enemy unit returned from check_around()
            enemy_unit = self.check_around(unit, enemy)
            # check if enemy unit is not none and unit is combat unit - soldier or warship
            if (type(unit) == Empire_Unit or type(unit) == Empire_Warship) and enemy_unit != None:
                # if enemy unit is worker -> kill it
                if type(enemy_unit) == Empire_Worker and type(unit) == Empire_Unit:
                    unit_locs[unit.loc[0]][unit.loc[1]] = 1
                    # update unit_locs board and unit location and empire units list
                    if version: # graphical implementation
                        self.b.remove_widget(enemy_unit) # remove from board
                        if enemy_unit.name == self.empire.name: # if unit belonged to player empie display lost unit message
                            self.Lost_unit(enemy_unit.loc)
                        if unit.loc[1] % 2 == 0:
                            unit.pos = (7 + enemy_unit.loc[1] * 45, (enemy_unit.loc[0] + 1) * 50 + 8)
                        else:
                            unit.pos = (7 + enemy_unit.loc[1] * 45, enemy_unit.loc[0] * 50 + 65 / 2)

                        Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                        for hex in self.b.children:
                            if type(hex) == Empire_HexTile and hex.loc == unit.loc:
                                hex.occupied = False

                    unit.loc = enemy_unit.loc
                    unit_locs[unit.loc[0]][unit.loc[1]] = empire.name[0] + 'U'
                    enemy.workers -= 1
                    enemy.units.remove(enemy_unit)

                elif type(enemy_unit) != Empire_Worker and type(unit) == type(enemy_unit): # if enemy unit is combat unit too
                    # if friendly unit power is higher - > destroy the enemy unit
                    if unit.power >= enemy_unit.power:
                        unit.power -= enemy_unit.power # reduce unit's power
                        # update unit_locs board and unit location and empire units list
                        unit_locs[unit.loc[0]][unit.loc[1]] = 1
                        if version: # graphical implementation
                            self.b.remove_widget(enemy_unit) # remove from board
                            if enemy_unit.name == self.empire.name:
                                self.Lost_unit(enemy_unit.loc)
                            if enemy_unit.loc[1] % 2 == 0:
                                unit.pos = (7 + enemy_unit.loc[1] * 45, (enemy_unit.loc[0] + 1) * 50 + 8)
                            else:
                                unit.pos = (7 + enemy_unit.loc[1] * 45, enemy_unit.loc[0] * 50 + 65 / 2)
                            Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                            for hex in self.b.children:
                                if type(hex) == Empire_HexTile and hex.loc == unit.loc:
                                    hex.occupied = False

                        unit.loc = enemy_unit.loc
                        unit_locs[unit.loc[0]][unit.loc[1]] = empire.name[0] + unit.class_name
                        # update enemy empire army / fleet
                        if type(unit) == Empire_Unit:
                            enemy.army -= 1
                        else:
                            enemy.ships -= 1
                        enemy.units.remove(enemy_unit)

                    # if enemy unit has more power than friendly unit -> retreat
                    elif unit.power < enemy_unit.power:
                        max_dis = -inf # max distance from enemy unit
                        curr_loc = unit.loc
                        # loop around the unit to find coordinate to escape to
                        if unit.loc[1] % 2 == 0:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                                if 48 > tile[0] >= 0 <= tile[1] < 70:
                                    if (type(unit) == Empire_Unit or type(unit) == Empire_Worker) and topo_map[tile[0]][
                                        tile[1]] != 'w' and topo_map[tile[0]][tile[1]] != 'm':
                                        dis = math.sqrt(
                                            ((enemy_unit.loc[0] - tile[0]) ** 2) + ((enemy_unit.loc[1] - tile[1]) ** 2))
                                        if dis > max_dis:
                                            max_dis = dis
                                            curr_loc = tile
                                    elif type(unit) == Empire_Warship and (
                                            topo_map[tile[0]][tile[1]] == 'w' or topo_map[tile[0]][tile[1]] == 'p'):
                                        dis = math.sqrt(
                                            ((enemy_unit.loc[0] - tile[0]) ** 2) + ((enemy_unit.loc[1] - tile[1]) ** 2))
                                        if dis > max_dis:
                                            max_dis = dis
                                            curr_loc = tile

                        else:
                            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                                if 48 > tile[0] >= 0 <= tile[1] < 70:
                                    if (type(unit) == Empire_Unit or type(unit) == Empire_Worker) and topo_map[tile[0]][
                                        tile[1]] != 'w' and topo_map[tile[0]][tile[1]] != 'm':
                                        dis = math.sqrt(
                                            ((enemy_unit.loc[0] - tile[0]) ** 2) + ((enemy_unit.loc[1] - tile[1]) ** 2))
                                        if dis > max_dis:
                                            max_dis = dis
                                            curr_loc = tile
                                    elif type(unit) == Empire_Warship and (
                                            topo_map[tile[0]][tile[1]] == 'w' or topo_map[tile[0]][tile[1]] == 'p'):
                                        dis = math.sqrt(
                                            ((enemy_unit.loc[0] - tile[0]) ** 2) + ((enemy_unit.loc[1] - tile[1]) ** 2))
                                        if dis > max_dis:
                                            max_dis = dis
                                            curr_loc = tile
                        # check if coordiante isnt unit's own location
                        if curr_loc != unit.loc:
                            # update unit_locs and unit location
                            unit_locs[unit.loc[0]][unit.loc[1]] = 1
                            if version: # graphical implementation
                                if curr_loc[1] % 2 == 0:
                                    unit.pos = (7 + curr_loc[1] * 45, (curr_loc[0] + 1) * 50 + 8)
                                else:
                                    unit.pos = (7 + curr_loc[1] * 45, curr_loc[0] * 50 + 65 / 2)
                                Animation(x=unit.pos[0], y=unit.pos[1]).start(unit)
                                for hex in self.b.children:
                                    if type(hex) == Empire_HexTile and hex.loc == unit.loc:
                                        hex.occupied = False
                                    if type(hex) == Empire_HexTile and hex.loc == curr_loc:
                                        hex.occupied = True

                            unit.loc = curr_loc
                            unit_locs[unit.loc[0]][unit.loc[1]] = empire.name[0] + unit.class_name

    '''GENERAL FUNCTION - ADD UNITS'''

    def add_units(self, unit_locs, empire, empire2, empire3, enemy_empire, version):
        """
        Function Method :
            Firstly :
            The function checks if the empire is at war and the capital is in danger - there is an enemy unit with more
            power than garrisoned unit or there is no unit defending the capital. In this a soldier unit is deployed in
            the capital with more manpower than enemy unit.
            Secondly :
            The function calculates the amount of units required from each type to have numerical superiority against
            rival empires. Then it loops for the required amount and adds the units, depending on the version.
            =======================================================================================================
        :param unit_locs: 2d list of all the unit locations
        :param empire: current empire
        :param empire2: rival empire
        :param empire3: rival empire 2
        :param enemy_empire: enemy empire that empire is currently at war with
        :param version: True if the unpacking is intended for graphical implementation, else False if is for minimax run
        """
        # defense of the capital
        if empire.state == 'War':
            defender = None  # defender unit
            # check if there is a defender unit in the capital
            for unit in empire.units:
                if unit.loc == empire.capital:
                    defender = unit
                    break

            enemy_unit = None  # enemy unit near capital
            # loop around capital locations
            for i in range(empire.capital[0] - 1, empire.capital[0] + 2):
                for j in range(empire.capital[1] - 1, empire.capital[1] + 2):
                    if enemy_empire is not None and unit_locs[i][j] != 1 and unit_locs[i][j][:1] == enemy_empire.name[0]:
                        # check if enemy empire has a unit in the (i,j) location
                        for unit in enemy_empire.units:
                            if unit.loc == (i, j):
                                enemy_unit = unit
                            break
            # if these is an enemy unit
            if enemy_unit is not None:
                # if there is a defender -> add manpower to him
                if defender is not None and enemy_unit.power > defender.power:
                    defender.power += (int((enemy_unit.power - defender.power) / 500) + 1) * 500
                    empire.manpower -= (int((enemy_unit.power - defender.power) / 500) + 1) * 500

                elif defender is None: # if there is no defender - recruit him and give him enough manpower to defend
                    if version:
                        self.add_Unit(empire, empire.capital)
                    else:
                        self.add_soldier(unit_locs, empire, empire.capital)

                    for unit in empire.units:
                        if unit.loc == empire.capital:
                            unit.power += enemy_unit.power + 500
                            empire.power -= (enemy_unit.power + 500)

        # required amount of warships to have numerical superiority
        counter_units = empire.ships - empire2.ships - empire3.ships

        if counter_units <= 0:
            # loop through required amount and recruit based on version
            for i in range(abs(counter_units) + 1):
                if version:
                    self.add_WarShip(empire, random.choice(empire.cities))
                else:
                    self.add_ship(unit_locs, empire, random.choice(empire.cities))
        # required amount of soldiers to have numerical superiority
        counter_units = empire.army - empire2.army - empire3.army
        if counter_units <= 0:
            # loop through required amount and recruit based on version
            for i in range(abs(counter_units) + 1):
                if version:
                    self.add_Unit(empire, random.choice(empire.cities))
                else:
                    self.add_soldier(unit_locs, empire, random.choice(empire.cities))
        # required amount of workers to have numerical superiority
        counter_units = empire.workers - empire2.workers - empire3.workers
        if counter_units <= 0:
            # loop through required amount and recruit based on version
            for i in range(abs(counter_units) + 1):
                if version:
                    self.add_Worker(empire, random.choice(empire.cities))
                else:
                    self.add_worker(unit_locs, empire, random.choice(empire.cities))

    '''SUPPORT FUNCTIONS FOR MAIN MINIMAX FUNCTIONS'''
    '''--------------------------------------------'''

    def add_soldier(self, unit_locs, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Unit type to the empire and unit locations board *
            =========================================================================================
            * if the city in which the unit is deployed has no other units and empire.treasury >= 1000 and empire.manpower >= 1000
        :param unit_locs: 2d list with all the units locations
        :param empire: empire to whioh the unit will be added
        :param loc: target spawn location
        """
        if empire.treasury >= 1000 and empire.manpower >= 1000 and unit_locs[loc[0]][loc[1]] == 1:
            s = Empire_Unit((0, 0), random.choice(empire.cities), empire.name)
            empire.treasury -= 1000
            empire.manpower -= 1000
            empire.army += 1
            unit_locs[empire.capital[0]][empire.capital[1]] = empire.name[0] + 'U'
            empire.units.append(s)

    def add_ship(self, unit_locs, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Warship type to the empire and unit locations board *
            ============================================================================================
            * if the city in which the unit is deployed has sea tile around it and no other units there and empire.treasury >= 2000 and empire.manpower >= 1000

        :param unit_locs: unit_locs: 2d list with all the units locations
        :param empire: empire to whioh the unit will be added
        :param loc: target spawn location
        """
        loc_x = 0
        loc_y = 0
        free_tile = False

        for x in range(loc[0] - 1, loc[1] + 2):
            for y in range(loc[0] - 1, loc[1] + 2):
                if x >= 0 and x < 48 and y >= 0 and y < 70 and (locations[x][y] == 'w' or locations[x][y] == 'p') and \
                        unit_locs[x][y] == 1:
                    loc_x = x
                    loc_y = y
                    free_tile = True

        if empire.treasury >= 2000 and empire.manpower > 1000 and free_tile:
            s = Empire_Unit((0, 0), (loc_x, loc_y), empire.name)
            empire.treasury -= 2000
            empire.manpower -= 1000
            empire.ships += 1
            unit_locs[loc_x][loc_y] = empire.name[0] + 'S'
            empire.units.append(s)

    def add_worker(self, unit_locs, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Worker type to the empire and unit locations board *
            ===========================================================================================
            * if the city outskirts in which the unit is deployed have no other units and empire.treasury >= 500 and empire.manpower >= 300

        :param unit_locs: unit_locs: 2d list with all the units locations
        :param empire: empire to whioh the unit will be added
        :param loc: target spawn location
        """
        loc_x = 0
        loc_y = 0
        free_tile = False
        for x in range(loc[0] - 1, loc[1] + 2):
            for y in range(loc[0] - 1, loc[1] + 2):
                if x >= 0 and x < 48 and y >= 0 and y < 70 and locations[x][y] != 'w' and locations[x][y] != 'm' and \
                        unit_locs[x][y] == 1:
                    loc_x = x
                    loc_y = y
                    free_tile = True

        if empire.treasury >= 500 and empire.manpower > 300 and free_tile:
            s = Empire_Unit((0, 0), (loc_x, loc_y), empire.name)
            empire.treasury -= 500
            empire.manpower -= 300
            empire.workers += 1
            unit_locs[loc_x][loc_y] = empire.name[0] + 'U'
            empire.units.append(s)

    def shore_is_close(self, a, b, board, empire):
        """
        Function Method :
            Function that searches nearby around given coordinates for shore - friendly or uncolonized
            ==========================================================================================
        :param a: x coordinate of the naval unit's location
        :param b: y coordinate of the naval unit's location
        :param board: empire board
        :param empire: empire which the naval unit serves
        :return: True if found a shore, else False
        """
        if b % 2 == 0:
            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                tile = (a + new_position[0], b + new_position[1])
                if board[tile[0]][tile[1]] == 'w' or board[tile[0]][tile[1]] == 'p':
                    if board[tile[0] - 2][tile[1]] == empire.name[0] or board[tile[0]][tile[1] - 2] == empire.name[0] or \
                            board[tile[0] - 2][tile[1] - 2] == empire.name[0]:
                        return True
                    if board[tile[0] + 2][tile[1]] == empire.name[0] or board[tile[0]][tile[1] + 2] == empire.name[0] or \
                            board[tile[0] + 2][tile[1] + 2] == empire.name[0]:
                        return True
        else:
            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                tile = (a + new_position[0], b + new_position[1])
                if board[tile[0]][tile[1]] == 'w' or board[tile[0]][tile[1]] == 'p':
                    if board[tile[0] - 2][tile[1]] == empire.name[0] or board[tile[0]][tile[1] - 2] == empire.name[0] or \
                            board[tile[0] - 2][tile[1] - 2] == empire.name[0]:
                        return True
                    if board[tile[0] + 2][tile[1]] == empire.name[0] or board[tile[0]][tile[1] + 2] == empire.name[0] or \
                            board[tile[0] + 2][tile[1] + 2] == empire.name[0]:
                        return True

        return False

    def check_around(self, unit, enemy):
        """
        Function Method :
            Function that searches around a unit for hostile units of its class
            ===================================================================
        :param unit: friendly unit that the function searches around him to find enemies
        :param enemy: enemy empire
        :return: the enemy unit if found one, else return None
        """
        if unit.loc[1] % 2 == 0:
            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (1, 1)]:
                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                if 0 <= tile[0] < 48 and 0 <= tile[1] < 70:
                    for enemy_unit in enemy.units:
                        if enemy_unit.loc == tile and (type(enemy_unit) == type(unit) or type(Empire_Worker)):
                            return enemy_unit
        else:
            for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0), (-1, -1), (-1, 1)]:
                tile = (unit.loc[0] + new_position[0], unit.loc[1] + new_position[1])
                if 0 <= tile[0] < 48 and 0 <= tile[1] < 70:
                    for enemy_unit in enemy.units:
                        if enemy_unit.loc == tile and (type(enemy_unit) == type(unit) or type(Empire_Worker)):
                            return enemy_unit
        return None

    def recreate_unit_list(self, empire):
        """
        ___Note___ :
        Since deepcopy doesnt work on Kivy objects and it's param, I have to do it manually
        Function Method :
            Function that creates a unit list for clone empire (for minimax), recreates original unit and its dict and returns it
            =====================================================================================================================
        :param empire:
        :return: new unit list for clone empire
        """
        units_arr = []
        for unit in empire.units:
            x = unit.__dict__.copy()
            if type(unit) == Empire_Unit:
                s = Empire_Unit((0, 0), (0, 0), "")
                s.__dict__ = x
                units_arr.append(s)

            if type(unit) == Empire_Worker:
                s = Empire_Worker((0, 0), (0, 0), "")
                s.__dict__ = x
                units_arr.append(s)

            if type(unit) == Empire_Warship:
                s = Empire_Warship((0, 0), (0, 0), "")
                s.__dict__ = x
                units_arr.append(s)

        return units_arr

    def copy_empire(self, empire):
        """
        ___Note___ :
        Since deepcopy doesnt work on Kivy objects and it's param, I have to do it manually
        Function Method :
            Function that creates a clone empire (for minimax), recreates its dict and returns it
            =====================================================================================
        :param empire: empire for cloning
        :return: clone empire
        """
        clone = Empire(0, 0, (0, 0), empire.name, self)
        clone.__dict__ = empire.__dict__.copy()
        clone.units = self.recreate_unit_list(empire)
        clone.farm_locs = copy.deepcopy(empire.farm_locs)
        clone.tile_arr = copy.deepcopy(empire.tile_arr)
        clone.dip1 = copy.deepcopy(empire.dip1)
        clone.dip2 = copy.deepcopy(empire.dip2)
        return clone

    def check_neighbour(self, x, y, empire):
        """
        Function Method :
            Function that receives a x, y coordinate and return the first instance of a rival empire tile around it
            =======================================================================================================
        :param x: x coordinate
        :param y: y coordinate
        :param empire: rival empire
        :return: number of rival empire tiles around it (1 or 0)
        """
        for i in range(x - 1, x + 2):
            for j in range(y - 1, y + 2):
                if 0 <= i < 48 and 0 <= j < 70 and empire.tile_arr[i][j] == 'O':
                    return 1
        return 0

    def colonize(self, unit, unit_locs, empire, tile, version):
        """
        Function Method :
            Function that runs around given 'tile' location and if there is a city
            there it deploys a soldier and a  worker unit there and updates unit score
            ==========================================================================
        :param unit: naval unit that does the colonize action
        :param unit_locs: unit locations to check if there aren't already units present in colonize destination
        :param empire: empire for add_unit functions
        :param tile: target tile that the search commences around
        :param version: True if this fucntion is intended for graphical representation or False if part of minimax run
        :return: return back to the running of previous function
        """
        for i in range(tile[0] - 1, tile[0] + 2):
            for j in range(tile[1] - 1, tile[1] + 2):
                if locations[i][j] == 'c':
                    if version:
                        self.add_Unit(empire, (i, j))
                    else:
                        self.add_soldier(unit_locs, empire, (i, j))

                    if version:
                        self.add_Worker(empire, (i, j))
                    else:
                        self.add_worker(unit_locs, empire, (i, j))
                    unit.score += 1
                    return

    '''==========================================SUPPORT FUNCTIONS==================================================='''

    def checkWin(self):
        """
        Function Method :
            Function that checks if the game is over
            ========================================
        """
        # case year is not end year
        if self.year < 0:
            # if one of the conidtions below is true, all widgets in the screen are removed and the screen switches to victory screen (see Screens.py)
            if self.empire.state == 'War' and self.e1.state == 'Defeat' and self.e2.state == 'Defeat':
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.empire, None, None)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'
            elif self.e1.state == 'War' and self.empire.state == 'Defeat' and self.e2.state == 'Defeat':
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.e1, None, None)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'
            elif self.e2.state == 'War' and self.empire.state == 'Defeat' and self.e1.state == 'Defeat':
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.e2, None, None)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'

        # if year is 0 which means it's the final year the game will run then switch to victory screen while clearing all the widgets and checking superamcy
        elif self.year == 0:
            if self.supremacy(self.empire, self.e1) and self.supremacy(self.empire, self.e2):
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.empire, self.e1, self.e2)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'
            elif self.supremacy(self.e1, self.empire) and self.supremacy(self.e1, self.e2):
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.e1, self.empire, self.e2)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'
            elif self.supremacy(self.e2, self.empire) and self.supremacy(self.e2, self.e1):
                self.clear_widgets()
                game_screen = self.manager.get_screen('Victory screen')
                game_screen.init_scoring(self.e2, self.empire, self.e1)
                self.manager.current = 'Victory screen'
                self.manager.transition.direction = 'right'

    def supremacy(self, empire, empire2):
        """
        Function Method :
            Function that check which empire has higher parameters and returns bool result
            The function creates 2 counters and for each parameter they increase
            ==============================================================================
        :param empire:
        :param empire2:
        :return: True if empire is stronger than empire2, else False
        """
        counter1 = 0  # counter for empire
        counter2 = 0  # counter for empire2

        if empire.army > empire2.army:
            counter1 += 1
        elif empire.army < empire2.army:
            counter2 += 1
        if empire.workers > empire2.workers:
            counter1 += 1
        elif empire.workers < empire2.workers:
            counter2 += 1
        if empire.farms > empire2.farms:
            counter1 += 1
        elif empire.farms < empire2.farms:
            counter2 += 1
        if empire.tiles > empire2.tiles:
            counter1 += 1
        elif empire.tiles < empire2.tiles:
            counter2 += 1
        if empire.tiles > empire2.tiles:
            counter1 += 1
        elif empire.treasury < empire2.treasury:
            counter2 += 1
        if empire.treasury > empire2.treasury:
            counter1 += 1
        elif empire.manpower < empire2.manpower:
            counter2 += 1
        # return results
        if counter1 > counter2:
            return True
        else:
            return False

    def check_defeat(self, empire):
        """
        Function Method :
            Function that checks whether an empire is defeated or close to defeat.
            If the empire is defeated - all its stats will be reset and all possessions
            will be removed from the map, i.e territories, units...
            ===========================================================================
        :param empire - empire whose it's state is being checked:
        """
        if empire.state == 'War':
            """
            condition for defeat - if empire has less than 70% of it's original tiles and it's empire has been captured 
            or it has less than 50% of it's original tiles
            """
            if (
                    empire.tiles < empire.original_tiles * 0.7 and empire.capital_captured) or empire.tiles < empire.original_tiles * 0.5:
                '''RESETTING THE EMPIRE'S STATS AND PARAM'''
                empire.state = 'Defeat'
                empire.farms = 0
                empire.tiles = 0
                empire.original_tiles = 0
                empire.stability = 0
                empire.treasury = 0
                empire.army = 0
                empire.ships = 0
                empire.cities = 0
                empire.workers = 0
                empire.capital = (0, 0)
                empire.manpower = 0
                empire.tile_arr = buildBoard(48, 70)
                empire.cities = []
                # update the player of it's capitualtion
                self.UPDATESPopup(empire.name + " has capitulated")
                # run through board and erase all empire possessions
                for child in self.b.children:
                    target_source = ''
                    city_source = ''
                    if empire.name == 'Rome':
                        target_source = '35_rome_hex.png'
                        city_source = '35_rome_hex.png_city'
                    elif empire.name == 'Carthage':
                        target_source = '36_carthage_hex.png'
                        city_source = '36_carthage_hex_city.png'
                    elif empire.name == 'Egypt':
                        target_source = '37_egypt_hex.png'
                        city_source = '37_egypt_hex_city.png'
                    # removal of tiles and farms
                    if type(child) == Empire_HexTile and (child.source == os.path.join('assets', 'images',
                                                                                       target_source) or child.source == os.path.join(
                        'assets', 'images', city_source) or empire.farm_locs[child.loc[0]][child.loc[1]] == 'O'):
                        j = child.loc[1]
                        i = child.loc[0]
                        if child.loc[1] % 2 == 0:
                            if background.read_pixel(j * dis_width + 10,
                                                     background.height - dis_height - i * dis_height) == green:
                                if i < 25:
                                    child.source = os.path.join('assets', 'images', '18_hex_green.png')
                                else:
                                    child.source = os.path.join('assets', 'images', '18_hex_green_alt.png')
                            elif background.read_pixel(j * dis_width + 10,
                                                       background.height - dis_height - i * dis_height) == yellow:
                                child.source = os.path.join('assets', 'images', '19_hex_yellow.png')
                            else:
                                child.source = os.path.join('assets', 'images', '39_hex_grey.png')
                        else:
                            if background.read_pixel(j * dis_width + 10,
                                                     background.height - dis_height / 2 - i * dis_height) == green:
                                if i < 25:
                                    child.source = os.path.join('assets', 'images', '18_hex_green.png')
                                else:
                                    child.source = os.path.join('assets', 'images', '18_hex_green_alt.png')
                            elif background.read_pixel(j * dis_width + 10,
                                                       background.height - dis_height / 2 - i * dis_height) == yellow:
                                child.source = os.path.join('assets', 'images', '19_hex_yellow.png')
                            else:
                                child.source = os.path.join('assets', 'images', '39_hex_grey.png')
                # removal of units
                for unit in empire.units:
                    self.b.remove_widget(unit)
                # resetting of the lists
                empire.units = []
                empire.farm_locs = buildBoard(48, 70)
                # reset other empires states to peace
                if empire == self.e1:
                    self.empire.state = 'Peace'
                    self.e2.state = 'Peace'
                elif empire == self.e2:
                    self.empire.state = 'Peace'
                    self.e1.state = 'Peace'
                else:
                    self.e2.state = 'Peace'
                    self.e1.state = 'Peace'
            # if the empire is close to capitulation either will happen : if it is the player empire a warning will be issued, else the AI empire will try to beg for peace
            elif (
                    empire.tiles <= empire.original_tiles * 0.8 and empire.capital_captured) or empire.tiles <= empire.original_tiles * 0.6:
                if empire != self.empire:
                    self.decisions_Popup(empire, "peace")
                else:
                    self.UPDATESPopup("NEED TO SIGN PEACE!")

    '''____________UNIT RECRUITMENT___________ '''

    def add_Unit(self, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Unit type to the graphical board *
            =========================================================================
            * if the city in which the unit is deployed has no other units and empire.treasury >= 1000 and empire.manpower >= 1000
            :param empire: empire to add the unit
            :param loc: locations of the city where unit is deployed
        """
        free = True
        for child in self.b.children:
            if type(child) == Empire_HexTile and child.loc == loc and child.occupied == True:
                free = False
                break

        if empire.treasury >= 1000 and empire.manpower >= 1000 and free:
            corrector_y = 0
            if loc[1] % 2 == 0:
                corrector_y = 57
            else:
                corrector_y = 65 / 2

            if empire == self.b.Rome:
                self.s = Empire_Unit((7 + loc[1] * 45, corrector_y + loc[0] * 50), loc, "Rome")
            elif empire == self.b.Carthage:
                self.s = Empire_Unit((7 + loc[1] * 45, corrector_y + loc[0] * 50), loc, "Carthage")
            else:
                self.s = Empire_Unit((7 + loc[1] * 45, corrector_y + loc[0] * 50), loc, "Egypt")

            self.b.add_widget(self.s)

            for hex in self.b.children:
                if type(hex) == Empire_HexTile and hex.loc[0] == self.s.loc[0] and hex.loc[1] == self.s.loc[1]:
                    hex.occupied = True

            empire.treasury -= 1000
            empire.manpower -= 1000
            empire.army += 1
            empire.units.append(self.s)
            if empire == self.empire:
                self.max_score = self.empire.army * 3 + self.empire.workers * 3 + self.empire.ships * 3
                self.update_labels(empire)

    def add_Worker(self, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Worker type to the graphical board *
            ===========================================================================
            * if the city outskirts in which the unit is deployed have no other units and empire.treasury >= 500 and empire.manpower >= 300
            :param empire: empire to add the unit
            :param loc: locations of the city where unit is deployed - the unit will be deployed in the surrounding tiles
        """
        range_x = 0
        range_y = 0
        slave_market = False
        free = True

        for x in range(loc[0] - 1, loc[0] + 2):
            for y in range(loc[1] - 1, loc[1] + 2):
                if x >= 0 and x < 48 and y >= 0 and y < 70:
                    if empire == self.e1:
                        if locations[x][y] != 'w' and locations[x][y] != 'p' and locations[x][y] != 'm' and \
                                self.empire.tile_arr[x][y] != 'O' and self.e2.tile_arr[x][y] != 'O':
                            range_x = y
                            range_y = x
                            slave_market = True
                            break
                    elif empire == self.empire:
                        if locations[x][y] != 'w' and locations[x][y] != 'p' and locations[x][y] != 'm' and \
                                self.e1.tile_arr[x][y] != 'O' and self.e2.tile_arr[x][y] != 'O':
                            range_x = y
                            range_y = x
                            slave_market = True
                            break
                    else:
                        if locations[x][y] != 'w' and locations[x][y] != 'p' and locations[x][y] != 'm' and \
                                self.empire.tile_arr[x][y] != 'O' and self.e1.tile_arr[x][y] != 'O':
                            range_x = y
                            range_y = x
                            slave_market = True
                            break

        for child in self.b.children:
            if type(child) == Empire_HexTile and child.loc == (range_y, range_x) and child.occupied == True:
                free = False
                break

        if empire.treasury >= 500 and empire.manpower >= 300 and slave_market and free:
            corrector_y = 0
            if range_x % 2 == 0:
                corrector_y = 57
            else:
                corrector_y = 65 / 2

            if empire == self.b.Rome:
                self.s = Empire_Worker((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Rome")
            elif empire == self.b.Carthage:
                self.s = Empire_Worker((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Carthage")
            else:
                self.s = Empire_Worker((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Egypt")

            self.b.add_widget(self.s)
            for hex in self.b.children:
                if type(hex) == Empire_HexTile and hex.loc[0] == self.s.loc[0] and hex.loc[1] == self.s.loc[1]:
                    hex.occupied = True

            empire.treasury -= 500
            empire.manpower -= 300
            empire.workers += 1
            empire.units.append(self.s)
            if empire == self.empire:
                self.max_score = self.empire.army * 3 + self.empire.workers * 3 + self.empire.ships * 3
                self.update_labels(empire)

    def add_WarShip(self, empire, loc):
        """
        Function Method :
            Function that creates and adds an Empire_Warship type to the graphical board *
            ============================================================================
            * if the city in which the unit is deployed has sea tile around it and no other units there and empire.treasury >= 2000 and empire.manpower >= 1000
            :param empire: empire to add the unit
            :param loc: locations of the city where unit is deployed - the unit will be deployed in the sea tile nearby
        """
        free = True
        port = False
        range_x = 0
        range_y = 0
        for x in range(loc[0] - 1, loc[0] + 2):
            for y in range(loc[1] - 1, loc[1] + 2):
                if x >= 0 and x < 48 and y >= 0 and y < 70 and (locations[x][y] == 'w' or locations[x][y] == 'p'):
                    range_x = y
                    range_y = x
                    port = True
                    break

        for child in self.b.children:
            if type(child) == Empire_HexTile and child.loc == (range_y, range_x) and child.occupied == True:
                free = False
                break

        if empire.treasury >= 2000 and empire.manpower >= 1000 and port == True and free == True:
            corrector_y = 0
            if range_x % 2 == 0:
                corrector_y = 57
            else:
                corrector_y = 65 / 2

            if empire == self.b.Rome:
                self.s = Empire_Warship((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Rome")
            elif empire == self.b.Carthage:
                self.s = Empire_Warship((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Carthage")
            else:
                self.s = Empire_Warship((8 + range_x * 45, corrector_y + range_y * 50), (range_y, range_x), "Egypt")

            self.b.add_widget(self.s)

            for hex in self.b.children:
                if type(hex) == Empire_HexTile and hex.loc[0] == self.s.loc[0] and hex.loc[1] == self.s.loc[1]:
                    hex.occupied = True

            empire.treasury -= 2000
            empire.manpower -= 1000
            empire.ships += 1
            empire.units.append(self.s)
            if empire == self.empire:
                self.max_score = self.empire.army * 3 + self.empire.workers * 3 + self.empire.ships * 3
                self.update_labels(empire)

    '''________________POPUPS_________________ '''

    def UPDATESPopup(self, message):
        """
        popup widget that is fired when the game needs to tell something the player (errors, hints)
        :param message - string value of the message to the player:
        """
        layout = GridLayout(cols=1, padding=10)
        type = Label(text=message, font_size=26, font_style='bold')
        layout.add_widget(type)
        b = Button(text="ACKNOWLEDGED", font_size=28)
        layout.add_widget(b)
        popup = Popup(title="Notice", content=layout, size_hint=(None, None), size=(400, 400), auto_dismiss=False)
        popup.open()
        b.bind(on_release=popup.dismiss)

    def decisions_Popup(self, empire, proposal):
        """
        popup widget that is fired when a rival empire initiates diplomatic action to player.
        The popup has 2 options for the player (buttons) - agree or disagree to proposal
        :param empire: rival empire object
        :param proposal: string of the empire's proposal to the player
        """
        layout = GridLayout(cols=1, padding=10)
        type = Label(text=empire.name + " wants " + proposal, font_size=24, font_style='bold')
        layout.add_widget(type)
        popup = Popup(title="A Proposal", content=layout, size_hint=(None, None), size=(400, 400), auto_dismiss=False)
        # case peace
        if proposal == 'peace':
            b1 = Decisions_Btn((layout.width / 2, layout.height / 2), "Agree to " + proposal, self.empire, self,
                               size_hint=(0.5, 0.3))
            b2 = Decisions_Btn((layout.width / 2, layout.height / 2), "Disagree to " + proposal, self.empire, self,
                               size_hint=(0.5, 0.3))
            layout.add_widget(b1)
            layout.add_widget(b2)
            b1.bind(on_release=popup.dismiss)
            b2.bind(on_release=popup.dismiss)
        # case war
        elif proposal == 'War':
            b = Button(text="They will pay for this...", font_size=22)
            b.bind(on_release=popup.dismiss)
            layout.add_widget(b)
        # other diplomatic actions
        else:
            b1 = Decisions_Btn((layout.width / 2, layout.height / 2), "Agree to " + proposal, empire, self,
                               size_hint=(0.5, 0.3))
            b2 = Decisions_Btn((layout.width / 2, layout.height / 2), "Disagree to " + proposal, empire, self,
                               size_hint=(0.5, 0.3))
            layout.add_widget(b1)
            layout.add_widget(b2)
            b1.bind(on_release=popup.dismiss)
            b2.bind(on_release=popup.dismiss)

        popup.open()

    def player_diplomacy_Popup(self, empire, proposal, response):
        """
            popup widget that is fired when the player interacts with diplomacy menu buttons
            :param empire: rival empire object
            :param proposal: string of the rival empire's proposal to the player
            :param response: string of the rival empire response to player's proposal
        """
        layout = GridLayout(cols=1, padding=10)
        popup = Popup(title="Response from " + empire.name, content=layout, size_hint=(None, None), size=(400, 400),
                      auto_dismiss=False)
        # case relations
        if proposal == 'relations':
            if empire == self.e1:
                type = Label(text="Our relations with " + empire.name + " are " + str(self.empire.dip1["relations"]),
                             font_size=20, font_style='bold')
                layout.add_widget(type)
            else:
                type = Label(text="Our relations with " + empire.name + " are " + str(self.empire.dip2["relations"]),
                             font_size=20, font_style='bold')
                layout.add_widget(type)
        # case not relations and not war, i.e trade, non- aggression etc.
        elif proposal != 'War':
            type = Label(text=empire.name + " " + response + " to " + proposal, font_size=18, font_style='bold')
            layout.add_widget(type)
        # case war
        elif proposal == 'War':
            type = Label(text="TO WAR!", font_size=32, font_style='bold')
            layout.add_widget(type)

        b = Button(text="ACKNOWLEDGED", font_size=28)
        layout.add_widget(b)
        popup.open()
        b.bind(on_release=popup.dismiss)

    def Lost_unit(self, loc):
        """
        popup widget that is fired when enemy AI defeat player's forces
        :param loc: defeated unit's location
        """
        sound = SoundLoader.load('assets/audio/unit_killed.mp3')
        sound.play()
        layout = GridLayout(cols=1, padding=10)
        type = Label(text='We have lost a unit in tile' + str(loc[0]) + " " + str(loc[1]), font_size=24,
                     font_style='bold')
        layout.add_widget(type)
        b = Button(text="ACKNOWLEDGED", font_size=28)
        layout.add_widget(b)
        popup = Popup(title="A TRAGIC LOSS", content=layout, size_hint=(None, None), size=(400, 400),
                      auto_dismiss=False)
        popup.open()
        b.bind(on_release=popup.dismiss)

    '''_____________GAME UPDATES______________ '''

    # update empires label on change of resources values
    def update_labels(self, empire):
        self.remove_widget(self.labels)
        # GridLayout to house resource buttons in the game screen
        self.labels = GridLayout(rows=1, pos=(self.width * 0.1, self.height * 0.93), size_hint=(0.5, 0.05), spacing=10)
        self.empire.update_titles()
        for i in range(3):
            self.labels.add_widget(
                Button(text=self.textures[i] + " : " + str(empire.labels[i]), font_size=self.width / 80,
                       font_style='Bold', background_normal=self.titles_source, background_down=self.titles_source_d))
        self.add_widget(self.labels)

    # update year value and text on label in the game screen
    def update_year(self):
        if self.year <= 250:
            self.year += 5
            self.turn += 1
            self.year_button.text = ('Year : %d' % self.year)

    # update scrollview vertical values
    def scroll_change(self, scrlv, instance, value):
        scrlv.scroll_y = value

    # update scrollview horizontal values
    def scroll_change2(self, scrlv, instance, value):
        scrlv.scroll_x = value

    # slider change update on instance
    def slider_change(self, s, instance, value):
        """
        :param s: slider object
        :param instance: on press / on release event
        :param value: current slider value
        """
        if value >= 0:  # this to avoid 'maximum recursion depth exceeded' error
            s.value = value

    # change self and scrlv size according to current winodw size
    def on_window_resize(self, window, width, height):
        self.width = width
        self.height = height
        self.scrlv.size = (self.width, self.height)

    # stop application on instance (press/ release)
    def exit(self, instance):
        App.get_running_app().stop()


'------------------------------------------------------------------------------------'


class Imperium(App):
    def build(self):
        """
        Class Imperium(App):
        ---------------------
        This is an extension of the app class, used to start the Kivy program
        :returns imperium screen manager
        """
        global root
        self.icon = os.path.join('assets', 'images', 'rome_symbol.png')
        path = os.path.dirname(os.path.realpath(__file__))  # path for system navigation in the project
        os.chdir(path)
        root = Imperium_Game()
        return root


if __name__ == '__main__':
    Imperium().run()
